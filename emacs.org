
		     An Emacs configuration tour

#+startup: overview
#+language: en
#+drawers: PROPERTIES FEEDSTATUS
#+filetags: emacs
#+todo: TODO | DONE CANCELED
#+style: <link rel="stylesheet" type="text/css" href="css/clean.css" />
#+options: H:2 toc:nil todo:t email:t ^:nil

* Introduction

I am using [[http://www.gnu.org/software/emacs/][GNU Emacs]] since the late '90 on various environments, both
at home or at work. At the beginning, I used it to write LaTeX files:
I found that tool more or less randomly while sitting in front of one
of the X Window terminals of my university. Today, whatever I have to
do with a computer, it ends in an Emacs buffer... In my current use,
Emacs has become a kind of interface over the computer's operating
system (whatever it is: Arch Linux, Ubuntu, Windows XP and Vista). But
suprisingly I feel like it has adapt to my needs rather than I have
limited myself to its features.

As an intensive Emacs user I had various needs related to Emacs
customization: Centralize all customization to be able to deploy
efficiently on multiple targets; Organize Emacs customization in the
order demanded by the flow of my needs rather than the one imposed by
the computer; Share Emacs customization; Gather links to external
tools; Log my contributions; Etc. Thus I have written an Org file
whose code blocks could be converted to the source file I use to
customize Emacs to my needs and, on the other hand, is the source of
the documentation you are reading.

*Downloads*

You can download both the [[file:emacs.org][Org file]] or the generated file:.emacs.

*References*

Most of the following code snippets I have written myself. Some were
copied from the [[https://lists.gnu.org/mailman/listinfo/help-gnu-emacs][gnu.emacs.help newsgroup]] or the [[http://www.emacswiki.org/][Emacs wiki]].

* General use
** Header							   :noexport:

#+begin_src emacs-lisp :tangle .emacs :noweb tangle
<<.emacs_header>>
#+end_src

** Checking emacs version

Despite a common misconception, GNU Emacs is actively maintained and
last versions were greatly improved. A recent version is required. It
can be downloaded from http://ftp.gnu.org/pub/gnu/emacs/.

#+begin_src emacs-lisp :tangle .emacs
(when (or (< emacs-major-version 24)
          (and (= emacs-major-version 24)
               (< emacs-minor-version 3)))
  (error "Wrong Emacs version, update or remove the configuration
  file"))
#+end_src

** Extending Emacs, packages repositories, etc

The easiest way to extend Emacs features is to use =list-package= and
install packages from remote repositories. But =package.el= is rather
new and not all libraries are available in the form of packages. When
a library must be installed by hand, a good practice is to always put
it in the directory =~/.emacs.d=. The load path is extended
accordingly.

#+begin_src emacs-lisp :tangle .emacs
(add-to-list 'load-path (expand-file-name "~/.emacs.d/"))
#+end_src

The default is to fetch packages from the GNU Emacs packages
repository. There are usefull packages in other places like [[http://tromey.com/elpa/][ELPA]] and
[[http://marmalade-repo.org/][Marmalade]].

#+begin_src emacs-lisp :tangle .emacs
(eval-after-load "package"
  '(progn
     (add-to-list 'package-archives '("elpa" . "http://tromey.com/elpa/"))
     (add-to-list 'package-archives '("marmalade". "http://marmalade-repo.org/packages/"))))
(package-initialize)
#+end_src

At the time of writing, I have activated the following packages:

#+begin_src emacs-lisp :exports results :results value raw
(let ((descriptions "|Package|Description|\n|---|\n"))
  (dolist (package package-alist descriptions)
    (let ((name (car package))
	  (desc (aref (cdr package) 2)))
    (setq descriptions 
	  (concat descriptions (format "|%s|%s|\n" name desc))))))
#+end_src

#+RESULTS:
| Package               | Description                                        |
|-----------------------+----------------------------------------------------|
| virtualenv            | Virtualenv for Python  -*- coding: utf-8 -*-       |
| symbols-mode          | List symbols of object files                       |
| php-mode              | major mode for editing PHP code                    |
| htmlize               | Convert buffer text and decorations to HTML.       |
| graphviz-dot-mode     | Mode for the dot-language used by graphviz (att).  |
| gnuplot               | drive gnuplot from within emacs                    |
| doctags               | Generation of tags documentation in Doxygen syntax |
| dictionary            | an interface to an RFC 2229 dictionary server      |
| color-theme-solarized | Solarized themes for Emacs                         |

All settings written using the customize library go to a dedicated
file that is loaded when the loading of the file file:.emacs ends.

#+begin_src emacs-lisp :noweb yes
<<.emacs_custom-file_loading>>
#+end_src

When the custom settings are loaded, a machine specific file is
loaded. The file name comes from the host name of the machine Emacs is
running on.

#+begin_src emacs-lisp :noweb yes
<<.emacs_system-name_loading>>
#+end_src

** Widening the screen

You feel like the computer screen is too narrow, don't you? So menu
bars, scroll bars and tool bars must be disabled. Whats more,
disabling this eyecandy may improve responsiveness when Emacs run on a
remote computer forwarding X11. Note that the content of the menu bar
is still available by pressing =f10= or the contextual menu bind to
=C-mouse-1=.

#+begin_src emacs-lisp :tangle .emacs
(when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+end_src

Don't know how to scroll buffers now that the scrollbar is gone? Read
the descriptions of the following key bindings: =M-v=, =C-v=, =M-C-v=,
=S-M-C-v=, =C-l=, =C-M-l=, =<prior>=, =<next>=, etc. Why should we add
scrollbars? By the way, the mode line indicates the percentage of the
buffer above the top of the window. And the column number is available
from the output of =C-x== (bind to =what-cursor-position=).

Another way to widen the screen is to truncate long lines and change
the text scale in secondary buffers. Restoring or changing the text
scale can be done interactively with =C-xC-0=, =C-xC-+= and =C-xC-=.

#+begin_src emacs-lisp :tangle .emacs
(defun alt-set-small-text-scale ()
  "Display buffer text in a smaller face than usual."
  (when (fboundp 'text-scale-set)
    (text-scale-set -1)))

(dolist (hook '(gdb-breakpoints-mode-hook gdb-inferior-io-mode-hook
                gdb-mode-hook gdb-locals-mode-hook gdb-frames-mode-hook
                speedbar-mode-hook compilation-mode-hook vc-dir-mode-hook
                occur-mode-hook apropos-mode-hook grep-mode-hook))
  (add-hook hook
            '(lambda ()
               (setq truncate-lines t)
               (alt-set-small-text-scale))))

(add-hook 'prog-mode-hook
          '(lambda ()
             (setq truncate-lines t)))
#+end_src

*** TODO Improve =menu-bar-open=				   :noexport:

Automatically turn =menu-bar-mode= on for graphic displays. The
main problem seems to be that =menu-bar-mode= is a global mode, not a
per frame mode (doesn't make sense).

** Generic modes

From the docstring: Generic modes provide basic comment and font-lock
functionality for "generic" files. (Files which are too small to
warrant their own mode, but have comment characters, keywords, and the
like.)

The file =generic-x.el= contains a collection of generic modes. The
default is to enable generic modes according to the host operating
system; I prefer to always define MS Windows generic modes for I
sometime have to work on script files for the MS Windows command
line...
#+begin_src emacs-lisp :tangle .emacs
(load "generic-x")
(setq generic-extras-enable-list
      (append generic-default-modes
	      generic-mswindows-modes
	      generic-unix-modes))
(load "generic-x")
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(when (eq system-type 'gnu/linux)
  (add-to-list 'auto-mode-alist
               '("/usr/lib/systemd/system" . ini-generic-mode)))
#+end_src

** Opening files

I sometime want the finding file commands to infer the name of the
file to find from the text under point.
#+begin_src emacs-lisp :tangle .emacs
(require 'ffap)
(setq ffap-require-prefix t)
(ffap-bindings)
#+end_src

** Auto insertion at file creation

Auto insertion of templates at file creation is enabled and the
location where templates are searched is defined.
#+begin_src emacs-lisp :tangle .emacs
(auto-insert-mode 1)
(let ((file (expand-file-name "~/Modèles")))
  (when (file-exists-p file)
    (setq auto-insert-directory file)))
#+end_src

** Revert buffers on file changes

#+begin_src emacs-lisp :tangle .emacs
(global-auto-revert-mode 1)
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'find-file-hook
          '(lambda()
             (when (and (buffer-file-name)
                        (equal (file-name-extension (buffer-file-name)) "log"))
               (auto-revert-tail-mode 1))))
#+end_src

** Moving between windows and selecting buffers

Usually the frame is split at most twice. I find =C-xo= sufficient to
change the selected window along the three candidates. When there are
fewer windows (for example while debugging), it is useful to have key
bindings (=S-left=, =S-right=, etc) for selection of windows in a
frame geometrically.

#+begin_src emacs-lisp :tangle .emacs
(windmove-default-keybindings)
(setq windmove-wrap-around t)
#+end_src

To select a buffer I often use =C-xb= and completion. When my brain
can't remember the buffer name, I use the default buffer menu
(accessible from =C-xC-b= and =C-uC-xC-b=) or I cycle through the
buffer ring with =C-<tab>= and =C-S-<iso-lefttab>=.

#+begin_src emacs-lisp :tangle .emacs
(global-set-key (kbd "C-<tab>") 'next-buffer)
(global-set-key (kbd "C-S-<iso-lefttab>") 'previous-buffer)
#+end_src

** Empty scratch buffer

#+begin_src emacs-lisp :tangle .emacs
(setq initial-scratch-message nil)
#+end_src

** Diary and calendar customization

A diary file is automatically created.

#+begin_src emacs-lisp :tangle .emacs
(let ((file (expand-file-name "~/.emacs.d/diary")))
  (when (not (file-exists-p file))
    (write-region "" nil file))
  (setq diary-file file))
#+end_src

The calendar is configured to match the french standards.

#+begin_src emacs-lisp :tangle .emacs
(setq european-calendar-style t
      calendar-time-display-form 
      '(24-hours ":" minutes
		 (if time-zone " (") time-zone (if time-zone ")"))
      calendar-week-start-day 1
      calendar-intermonth-text
      '(propertize
	(format "%2d"
		(car
		 (calendar-iso-from-absolute
		  (calendar-absolute-from-gregorian (list month day year)))))
	'font-lock-face 'font-lock-function-name-face))

(setq view-diary-entries-initially t
      number-of-diary-entries [0 2 2 2 2 4 1]
      mark-diary-entries-in-calendar t
      view-calendar-holidays-initially nil
      mark-holidays-in-calendar t
      general-holidays nil
      hebrew-holidays nil
      all-christian-calendar-holidays t
      islamic-holidays nil
      oriental-holidays nil)

(add-hook 'today-visible-calendar-hook 'calendar-mark-today)

(add-hook 'diary-display-hook 'fancy-diary-display)
#+end_src

French holidays are be added to the calendar. Note that Christian
holidays are already present into the calendar since we have set
=all-christian-calendar-holidays= to =t=.

#+begin_src emacs-lisp :tangle .emacs
(setq french-holiday
      '((holiday-fixed 1 1 "Jour de l'an")
        (holiday-fixed 5 1 "Fête du travail")
        (holiday-fixed 5 8 "Victoire 1945")
        (holiday-fixed 7 14 "Fête nationale")
        (holiday-fixed 11 1 "Toussaint")
        (holiday-fixed 11 11 "Armistice 1918")))

(setq holiday-other-holidays 
      (append french-holiday holiday-other-holidays))
#+end_src

*** TODO Configure Org-mode calendar				   :noexport:

** Org mode

#+begin_src emacs-lisp :tangle .emacs
(setq org-hide-leading-stars t
      org-log-done 'time
      org-directory (expand-file-name "~/.emacs.d/org")
      org-default-notes-file (expand-file-name "notes.org" org-directory))
(require 'org-remember)
(org-remember-insinuate)
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(when (featurep 'windmove)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(define-key global-map "\C-cr" 'org-remember)
(define-key global-map "\C-ca" 'org-agenda)
#+end_src

Org files have an option to set the language to use for translations
while exporting to HTML. When this option is set, one can deduce the
dictionary to use for spell checking. By the way I like to spell check
Org buffers on the fly.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'org-mode-hook
   '(lambda ()
      (require 'ispell)
      (ispell-set-spellchecker-params)
      (require 'org-exp)
      (let ((lang (plist-get (org-infile-export-plist) :language)))
        (when (and lang (assoc lang ispell-dictionary-alist))
          (setq ispell-local-dictionary lang)))
      (flyspell-mode 1)))
#+end_src

** PostScript printing 						   :noexport:

#+begin_src emacs-lisp :tangle .emacs
(setq ps-paper-type 'a4
      ps-font-size '(8 . 9.5))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(setq ps-print-header t
      ps-print-header-frame t
      ps-header-lines 2
      ps-left-header '(ps-get-buffer-name ps-header-dirpart)
      ps-right-header 
      '(ps-time-stamp-locale-default ps-time-stamp-hh:mm:ss)
      ps-print-footer t
      ps-print-footer-frame nil
      ps-footer-lines 1
      ps-right-footer nil
      ps-left-footer
      (list (concat "{pagenumberstring dup stringwidth pop"
		    " 2 div PrintWidth 2 div exch sub 0 rmoveto}")))
#+end_src

** Electric modes

Enable pairing to insert pairs of matching characters and enable
on-the-fly reindentation.

#+begin_src emacs-lisp :tangle .emacs
(electric-pair-mode 1)
(electric-indent-mode 1)
#+end_src

** Save place

Automatically save place of cursor in each file.

#+begin_src emacs-lisp :tangle .emacs
(setq-default save-place t)
(require 'saveplace)
#+end_src

** Archives display

#+begin_src emacs-lisp :tangle .emacs
(require 'tar-mode)
(setq tar-mode-show-date t)
#+end_src

** Time and date

When working in a console, it is sometime usefull to get the time:
=M-! date= is ok for this. To display the time in the modeline there
is =display-time-mode=.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'display-time-mode-hook
	  '(lambda ()
	     (setq display-time-day-and-date nil
		   display-time-24hr-format t 
		   display-time-use-mail-icon t
		   display-time-format "%A,%e %B %Y %R")))
#+end_src

** Syntax highlighting

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'font-lock-mode-hook
	  '(lambda ()
	     (show-paren-mode 1)))

(add-hook 'show-paren-mode-hook
	  '(lambda ()
	     (setq show-paren-style 'parenthesis)))
#+end_src

** Final new line

All files will have a newline at their end.

#+begin_src emacs-lisp :tangle .emacs
(setq require-final-newline t)
#+end_src

** Language environment

When using the =Latin-1= or =UTF-8= language environment, the
preferred input method use prefix modifiers (use =C-hI= to get a
description of any input method).

#+begin_src emacs-lisp :tangle .emacs
  (add-hook 'set-language-environment-hook
            '(lambda ()
               (let ((language-name current-language-environment))
                 (when 
                     (or (string= language-name "Latin-1")
                         (string= language-name "UTF-8"))
                   (setq default-input-method 'latin-1-prefix))
                  (t nil))))
#+end_src

But there are other input methods I use: For example the TeX method.
Key sequences are defined to easily set the input methods I need.

#+begin_src emacs-lisp :tangle .emacs
(dolist (elt '(("1" . "latin-1-prefix")
	       ("9" . "latin-9-prefix")
	       ("u" . "TeX")))
  (define-key mule-keymap (car elt)
    `(lambda ()
       (interactive)
       (set-input-method ,(cdr elt)))))
#+end_src

** Display settings

If the display can display images, image files are rendered as images.

#+begin_src emacs-lisp :tangle .emacs
(when (display-images-p)
  (auto-image-file-mode 1))
#+end_src

When a buffer is already displayed, its frame is raised when the
default is to create a new window displaying that buffer.

#+begin_src emacs-lisp :tangle .emacs
(setq display-buffer-reuse-frames t)
#+end_src

Group buffers by their major modes when using the contextual menu to
select a buffer.

#+begin_src emacs-lisp :tangle .emacs
(eval-after-load "mouse"
  (progn
    (setq mouse-buffer-menu-mode-mult 2)
    (add-to-list 'mouse-buffer-menu-mode-groups '("Dired" . "Dired"))
    (add-to-list 'mouse-buffer-menu-mode-groups '("tex" . "TeX/LaTeX"))
    t))
#+end_src

** Frame customization definitions

A function (binded to =f11=) is defined to maximize/restore the
selected frame.

#+begin_src emacs-lisp :tangle .emacs
(global-set-key [f11] 'alt-fullscreen-both)

(defun alt-fullscreen-both ()
  """Toggle fullscreen parameter for selected frame."""
  (interactive)
  (let ((frame-type (framep (selected-frame))))
    (when (or (eq frame-type 'x)
              (eq frame-type 'w32))
      (let* ((frame (selected-frame))
             (value (frame-parameter frame 'fullscreen)))
        (cond 
         ((eq value 'fullboth) 
          (set-frame-parameter frame 'fullscreen nil)
          (when (eq system-type 'windows-nt)
            (w32-send-sys-command 61728)))
         ((eq value nil) 
          (set-frame-parameter frame 'fullscreen 'fullboth)
          (when (eq system-type 'windows-nt)
            (w32-send-sys-command 61488)))
         (t nil))))))
#+end_src

Various customizations are done for each frame depending on the frame
type: An X Window frame, a frame on MS-Windows display or a termcap
frame.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'after-make-frame-functions 'alt-frame-customization)

(defun alt-frame-customization (frame)
  "To be run after frame creation."
 (let ((frame-type (framep frame)))
   (cond ((or (eq frame-type 'x)
	      (eq frame-type 'w32))
	  (setq x-select-enable-clipboard t
		x-stretch-cursor t)
	  (setq-default indicate-empty-lines t)
	  (mouse-avoidance-mode 'banish)
	  (add-hook 'gdb-mode-hook
		    '(lambda ()
		       (setq gdb-many-windows t
			     gdb-speedbar-auto-raise nil))))
	 ((eq frame-type 't)
	  (let ((terminal-type (getenv "TERM"))
		(lang current-language-environment))
	    (cond ((string-match "^xterm" terminal-type)
		   (xterm-mouse-mode 1)
		   (setq minor-mode-alist 
			 (remove '(xterm-mouse-mode (" Mouse")) 
				 minor-mode-alist)))
		  ((equal terminal-type "linux")
		   (setq browse-url-browser-function 'browse-url-lynx-emacs)
		   (when (equal lang "UTF-8") 
		     (set-keyboard-coding-system 'utf-8)))
		  (t nil)))))))
#+end_src

#+begin_src emacs-lisp
(setq default-frame-alist
      '((height . 40)
	(width . 80)
	(menu-bar-lines . nil)
	(tool-bar-lines . nil)
	(vertical-scroll-bars . nil)
	(background-color . "#2e3434")
	(background-mode . dark)
	(foreground-color . "#eeeeec")
	(mouse-color . "#8ae234")
	(font . "Consolas-12")
	(cursor-color . "#fce94f")))
#+end_src

It is better to customize the file file:~/.Xresources:

#+begin_src x-resource-generic-mode
!Emacs colors
Emacs.foreground: #eeeeec
Emacs.background: #2e3434
Emacs.cursorColor: #fce94f
Emacs.borderColor: #2e3434
Emacs.pointerColor: #8ae234
Emacs.mouseColor: #8ae234

! Emacs frame customization
!Emacs.fullscreen: maximized
Emacs.menuBar: off
Emacs.toolBar: off
Emacs.verticalScrollBars: off
!Emacs.font: Inconsolata-13

! Emacs faces customization
Emacs.fringe.attributeBackground: grey20
Emacs.header-line.attributeBackground: grey30
Emacs.link.attributeForeground: cyan
Emacs.link.attributeUnderline: false
#+end_src

** Documentation reader

#+begin_src emacs-lisp :tangle .emacs
(require 'info)
(define-key ctl-x-4-map "i" 'info-other-window)
(define-key ctl-x-5-map "i" 'info-other-frame)

(add-hook 'Info-mode-hook
	  '(lambda ()
	     (setq indicate-empty-lines nil
		   truncate-lines t)))

(defun info-other-frame ()
  "Like `info' but put Info buffer in another frame.
Only intended for interactive use."
  (interactive)
  (let* ((win (selected-window))
	 (wdp (window-dedicated-p win))
	 value)
    (unwind-protect
	(progn
	  (set-window-dedicated-p win nil)
	  (switch-to-buffer-other-frame
	   (save-window-excursion
	     (setq value (call-interactively 'info))
	     (current-buffer))))
      (set-window-dedicated-p win wdp))
    value))
#+end_src

I prefer to read manual pages with the =woman= command than the legacy
=man= command. It is configured to use the whole frame.

#+begin_src emacs-lisp :tangle .emacs
(require 'woman)
(defalias 'man 'woman)

(setq woman-fill-frame t
      woman-use-own-frame nil)

(define-key Info-mode-map "W" 'woman)
#+end_src

When using Emacs as a daemon, the default value of =woman-fontify=
will be =nil= because the daemon may open frames on displays that do
not support colors or different fonts.

#+begin_src emacs-lisp :tangle .emacs
(setq woman-fontify t)
#+end_src

** Server, daemon

A server is started if and only if the running process is not a daemon
and there is not already a server started. In that way the Emacs
client will always find someone to talk to.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'server-switch-hook 'raise-frame)

(load-library "server")
(when (not (or (server-running-p) (daemonp)))
  (server-start))
#+end_src

To have =emacsclient= called by =sudoedit=, =git= and other programs
when they are tell to edit a file, Bash configuration file
file:~/.bashrc contains the following snippet:

#+begin_src shell-script-mode 
builtin type -p emacsclient &>/dev/null
[ -n $@ ] && export EDITOR=emacsclient
#+end_src

** Desktop

The desktop file should be saved in the user home directory. Only ten
files are restored immediately in order not to slow down start up.
Tramp, ftp and log files are not restored, dired buffers too.

#+begin_src emacs-lisp :tangle .emacs
(load-library "desktop")
(setq desktop-dirname (expand-file-name "~")
      desktop-restore-eager 10
      desktop-lazy-verbose nil
      desktop-files-not-to-save
      "\\(^/[^/:]*:\\|(ftp)$\\|.*\.log\\)")

(add-to-list 'desktop-modes-not-to-save
             'dired-mode)
(add-to-list 'desktop-modes-not-to-save
             'info-mode)
#+end_src

** Various

#+begin_src emacs-lisp :tangle .emacs
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'scroll-left 'disabled nil)
#+end_src

* Programming

** File parser

Visited buffers will always be parsed for their semantic content and a
list of most recently used tags is maintained.

#+begin_src emacs-lisp :tangle .emacs
(add-to-list 'semantic-default-submodes 'global-semantic-mru-bookmark-mode)
(semantic-mode 1)
#+end_src

** Speedbar

I found that the speedbar is a nice way to browse files, tags and
documentation using the mouse. It deserves a key binding.

#+begin_src emacs-lisp :tangle .emacs
(define-key global-map "\M-0" 'speedbar)  
#+end_src

** Buffer indexes

Another way to browse tags found in the current buffer is to use the
index menu. A key binding is addded to programming modes to present to
the user the buffer indexes.

#+begin_src emacs-lisp :tangle .emacs
(setq imenu-auto-rescan t
      imenu-max-items 35)
(add-hook 'prog-mode-hook
          '(lambda ()
             (local-set-key "\C-ci" 'imenu)))
#+end_src

** Time stamps

The command =time-stamp= updates the time stamp string in the buffer.
The default format of the time stamp does not include the system name.
I found it usefull when working on a given file from different
computers.

#+begin_src emacs-lisp :tangle .emacs
(setq-default time-stamp-format "%:y-%02m-%02d %02H:%02M:%02S %u@%s")

(add-hook 'write-file-hooks '(lambda () (time-stamp)))
#+end_src

*** TODO How to insert a timestamp at point			   :noexport:

** Completion

The typical Emacs behavior when completing is preferred: `Typical Emacs
behavior is to complete as much as possible, then pause waiting for
further input. Then if TAB is hit again, show a list of possible
completions.'

#+begin_src emacs-lisp :tangle .emacs
(setq pcomplete-cycle-completions nil)
#+end_src

By the way when reading file or buffer names the case will be ignored.

#+begin_src emacs-lisp :tangle .emacs
(setq read-file-name-completion-ignore-case t
      read-buffer-completion-ignore-case t)
#+end_src

** Abbreviations

The file =~/.emacs.d/abbrev_defs= (or whatever the value of
=abbrev-file-name= is) defines abbreviations and their expansions. It
is read quietly.

#+begin_src emacs-lisp :tangle .emacs
(let ((file abbrev-file-name))
  (when (file-readable-p file)
    (read-abbrev-file file t)))
#+end_src

While editing buffers in programming modes, insertion of an
abbreviation is automatically expanded and replaced by its expansion.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'prog-mode-hook
          '(lambda ()
             (abbrev-mode 1)))
#+end_src

An other way to use abbreviations is to expand letters in the buffer
before point by looking for other words that start with those letters
in buffers. Expansion is performed dynamically. I am hooked to this.
To limit the number of dynamic expansions when editing files using
naming conventions mixing uppercase and lowercase letters, case is
significant while searching for expansions.

#+begin_src emacs-lisp :tangle .emacs
(setq dabbrev-case-fold-search nil)
#+end_src

** Whitespaces

#+begin_src emacs-lisp :tangle .emacs
(eval-after-load 'prog-mode
  (define-key prog-mode-map "\C-cw" 'whitespace-cleanup))
#+end_src

** Version control

I sometimes have directories both under [[http://subversion.apache.org/][Subversion]] and [[http://gitscm.org/][Git]]. As my
preferred version control backend is Git, the list of version control
backends must be reordered.

#+begin_src emacs-lisp :tangle .emacs
(setq vc-handled-backends (cons 'Git (remove 'Git vc-handled-backends)))
#+end_src

Comparing revisions using Ediff is so pleasant that it deserves a key
binding.

#+begin_src emacs-lisp :tangle .emacs
(global-set-key "\C-xv=" 'ediff-revision)
#+end_src

Spell checking is automatically enabled when editing log messages,
whether working with Git or Subversion from a shell, or using Emacs
version control interface.

Note that, when working with Git from a shell, the buffer opened to
edit a log message has =default-generic-mode= enabled because its
content match =generic-find-file-regexp= and
=generic-use-find-file-hook= default value is =t= .

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'find-file-hook
          '(lambda ()
             (when (string-match "^svn-commit" (buffer-name))
               (setq ispell-local-dictionary "english")
               (flyspell-mode 1))))

(add-hook 'default-generic-mode-hook
          '(lambda ()
             (when (equal (buffer-name) "COMMIT_EDITMSG")
               (setq ispell-local-dictionary "english")
               (flyspell-mode 1))))

(add-hook 'log-edit-mode-hook
          '(lambda ()
             (setq ispell-local-dictionary "english")
             (flyspell-mode 1)))
#+end_src

** Command interpreter

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'comint-mode-hook
	  '(lambda ()
	     (if (fboundp 'ansi-color-for-comint-mode-on)
		 (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t))
	     (setq comint-scroll-show-maximum-output t
		   indicate-empty-lines nil
		   comint-password-prompt-regexp 
		   "\\(\\([Ee]nter \\(?:same \\|the \\)?\\|[Oo]ld \\|[Nn]ew \\|'s \\|login \\|Kerberos \\|CVS \\|UNIX \\| SMB \\|LDAP \\|\\[sudo] \\|^\\)[Pp]assword\\( (again)\\)?\\|pass phrase\\|Mot de passe \\|\\(Enter \\|Repeat \\|Bad \\)?[Pp]assphrase\\)\\(?:, try again\\)?\\(?: for [^:]+\\)?:\\s *\\'")
	     (define-key comint-mode-map "\C-c\C-k" 'comint-kill-subjob)
	     (when (eq system-type 'windows-nt)
	       (setq comint-process-echoes 'on))))

(autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
#+end_src

** Spell checking

When writing code source, I like to have comments and string checked
for right spelling.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'prog-mode-hook
          '(lambda ()
             (setq ispell-local-dictionary "english"
                   flyspell-persistent-highlight nil)
             (flyspell-prog-mode)))
#+end_src
** Interactive shell

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'shell-mode-hook 
	  '(lambda ()
	     (ansi-color-for-comint-mode-on)
	     (setq shell-prompt-pattern "^\[[^$#\n]*\][$#] *"
		   shell-font-lock-keywords
		   '(("[ \t]\\([+-][^ \t\n]+\\)" 1 font-lock-comment-face)
		     ("^\\[[1-9][0-9]*\\]" . font-lock-string-face))
		   comint-password-prompt-regexp
		   "\\(\\([Ee]nter \\(?:same \\|the \\)?\\|[Oo]ld \\|[Nn]ew \\|'s \\|login \\|Kerberos \\|CVS \\|UNIX \\| SMB \\|LDAP \\|\\[sudo] \\|^\\)[Pp]assword\\( (again)\\)?\\|pass phrase\\|Mot de passe \\|\\(Enter \\|Repeat \\|Bad \\)?[Pp]assphrase\\)\\(?:, try again\\)?\\(?: for [^:]+\\)?:\\s *\\'")
	     (define-abbrev shell-mode-abbrev-table "null" "&> /dev/null")))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'sh-mode-hook
	  '(lambda ()
	     (define-key sh-mode-map "'" 'self-insert-command)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defun alt-skip-dedicated-windows ()
  "Select a non dedicated window."
  (let ((list nil))
    (while (window-dedicated-p (selected-window))
      (push (selected-window) list)
      (select-window (next-window nil 1 'visible))
      (if (member (selected-window) list)
	  (error "All windows are dedicated windows")))))

(defadvice shell (before skip-dedicated-windows activate)
  "Like `shell' but select a non dedicated window."
  (interactive)
  (alt-skip-dedicated-windows))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(global-set-key [f9] 'alt-shell-dwim)

(defun alt-shell-dwim (arg)
  "Run an inferior shell like `shell'. If an inferior shell as its I/O
through the current buffer, then pop the next buffer in `buffer-list'
whose name is generated from the string \"*shell*\". When called with
an argument, start a new inferior shell whose I/O will go to a buffer
named after the string \"*shell*\" using `generate-new-buffer-name'."
  (interactive "p")
  (let* ((shell-buffer-list
	  (let (blist)
	    (dolist (buff (buffer-list) blist)
	      (when (string-match "^\\*shell\\*" (buffer-name buff))
		(setq blist (cons buff blist))))))
	 (name (if current-prefix-arg 
		   (generate-new-buffer-name "*shell*")
		 (car shell-buffer-list))))
    (shell name)))
#+end_src

** Terminal emulation

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'term-mode-hook
	  '(lambda ()
	     (term-pager-toggle)))
#+end_src

** Compilation							   :noexport:

#+begin_src emacs-lisp
(add-hook 'compilation-mode-hook
	  '(lambda ()
	     (setq truncate-partial-width-windows nil)))
#+end_src

I use the single key binding =f8= to compile, display the compilation
buffer, recompile and delete the window displaying the compilation
buffer (in case it is the selected window).

#+begin_src emacs-lisp :tangle .emacs
(global-set-key [f8] 'alt-compile-dwim)

(defun alt-compile-dwim (arg)
  "A wrapper around both commands `compile' and `recompile'. 

When there is no buffer named *compilation* or when called with
an argument, run `compile'.

If a buffer named *compilation* exists but is not visible, it is
displayed. In case the *compilation* buffer exists and is
displayed in the selected window, the window is deleted. If the
,*compilation* buffer exists and it is displayed in a visible
window different than the selected window, run `recompile'."
  (interactive "P")
  (if arg 
      (call-interactively 'compile arg)
    (let* ((buff (get-buffer "*compilation*"))
           (win (get-buffer-window buff 'visible)))
      (cond
       ((and (bufferp buff) (not (windowp win)))
        (display-buffer buff))
       ((eq (window-buffer) buff)
        (delete-window win))
       ((bufferp buff) 
        (call-interactively 'recompile))
       (t
        (call-interactively 'compile))))))
#+end_src

** Make

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'makefile-gmake-mode-hook
	  '(lambda ()
	     (setq tab-width 3)))
#+end_src

** Spell checking

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'prog-mode-hook
          '(lambda ()
	     (setq ispell-local-dictionary "english"
		   flyspell-persistent-highlight nil)
	     (flyspell-prog-mode)))
#+end_src
** Visual interface to diff and patch

Prefer to run the visual interface to diff in a single frame and split
that frame vertically or horizontally according to the frame geometry.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'ediff-mode-hook
          '(lambda ()
             (setq ediff-window-setup-function 'ediff-setup-windows-plain)
             (when (< (* 2 (frame-height)) (frame-width))
               (setq ediff-split-window-function 'split-window-horizontally))))
#+end_src

** Debugger, GDB

#+begin_src emacs-lisp :tangle .emacs
(global-set-key [S-f8] 'gdb)

(add-hook 'gdb-mode-hook
	  '(lambda ()
	     (setq gdb-show-changed-values t
		   gdb-use-colon-colon-notation nil
		   gdb-use-separate-io-buffer t)))

(add-hook 'gud-mode-hook
	  '(lambda ()
	     (setq gud-tooltip-mode nil
		   gud-gdb-command-name "gdb --silent --annotate=3")))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defun alt-valgrind (file)
  (interactive "fEnter file: ")
  (shell-command (concat
		  "valgrind --leak-check=full  " file))
  (switch-to-buffer-other-window "*Shell Command Output*")
  (compilation-shell-minor-mode t))
#+end_src

** Support for C++

It is common for C++ developpers and C developpers to name their
header files with the =.h= extension. As I am more interested in C++,
the default is to visit such files in C++ mode. Whats more, candidate
extensions for the source file associated to a =.h= file are reordered
to privilege C++ usual extensions rather than C ones (see
=ff-find-other-file= binded to =C-co= for a way to switch between
implementation and declaration on a file name basis).

#+begin_src emacs-lisp :tangle .emacs
(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))

(require 'find-file)
(setcdr (assoc "\\.h\\'" cc-other-file-alist)
	(list (list ".cpp" ".cc" ".C" ".CC" ".cxx" ".c")))
#+end_src

Some abbreviation definitions for preprocessor directives are added.

#+begin_src emacs-lisp :tangle .emacs
(eval-after-load "cc-mode"
  (progn
    (define-skeleton cc-preprocessor-conditional-group
      "Insert a C preprocessor conditional group"
      "Group macro: " "#ifdef " str ?\n _ ?\n"#endif // " str ?\n)

    (define-skeleton cc-preprocessor-not-conditional-group
      "Insert a C preprocessor conditional group"
      "Group macro: " "#ifndef " str ?\n _ ?\n"#endif // " str ?\n)

    (define-skeleton cc-preprocessor-create-macro
      "Insert a C preprocessor macro creation"
      "Macro name: " "#define " str " " (skeleton-read "Macro expansion: ") _)

    (define-skeleton cc-preprocessor-include-directive
      "Insert a C preprocessor include directive"
      "Header name: " "#include " str _)
    t))

(add-hook 'c++-mode-hook
          '(lambda ()
             (define-abbrev c++-mode-abbrev-table "ppif" "" 'cc-preprocessor-conditional-group)
             (define-abbrev c++-mode-abbrev-table "ppnif" "" 'cc-preprocessor-not-conditional-group)
             (define-abbrev c++-mode-abbrev-table "ppd" "" 'cc-preprocessor-create-macro)
             (define-abbrev c++-mode-abbrev-table "ppi" "" 'cc-preprocessor-include-directive)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(require 'hideshow)
(add-hook 'c++-mode-hook
	  '(lambda ()
	     (setq comment-style 'extra-line)
	     (setq indent-tabs-mode nil)
             (c-set-style "ellemtel")
	     (setq c-cleanup-list '(empty-defun-braces
				    one-liner-defun
				    defun-close-semi
				    scope-operator
				    list-close-comma)
		   c-basic-offset 3)
	     (c-toggle-electric-state 1)
	     (c-toggle-hungry-state 1)
	     (c-toggle-auto-newline 1)
	     (subword-mode 1)
	     (hs-minor-mode 1)
	     (cwarn-mode 1)

	     (require 'find-file)
	     (add-to-list ff-search-directories ".")

	     (define-key c++-mode-map "\C-co" 'ff-find-other-file)
	     (define-key c++-mode-map "\C-ck" 'tags-apropos)
	     (define-key c++-mode-map "\C-m" 'c-context-line-break)))
#+end_src

** Support for Emacs Lisp

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'emacs-lisp-mode-hook
	  '(lambda ()
	     (set (make-local-variable 'comment-auto-fill-only-comments) t)
	     (set (make-local-variable 'imenu-sort-function) 
		  'imenu--sort-by-name)
	     (outline-minor-mode t)
	     (define-key emacs-lisp-mode-map "\C-c\C-f" 
	       'emacs-lisp-byte-compile)))
#+end_src

To speedup Emacs lisp execution, code can be compiled. The following
will compile a buffer on save if and only if an associated
byte-compiled file already exists.

#+begin_src emacs-lisp :tangle .emacs
(defun byte-compile-current-buffer ()
  "Compile the current buffer if its major mode is
`emacs-lisp-mode' and an associated compiled file already
exists."
  (interactive) 
  (when
      (and (eq major-mode 'emacs-lisp-mode)
           (file-exists-p (byte-compile-dest-file buffer-file-name)))
    (byte-compile-file buffer-file-name)))

(add-hook 'after-save-hook 'byte-compile-current-buffer)
#+end_src

** Support for Python

Linux distributions like Arch Linux ship with both Python 2.x and 3.x,
thus the list of interpreters must be expanded accordingly for file
mode determination.

#+begin_src emacs-lisp :tangle .emacs
(eval-after-load "python"
  (setq python-shell-interpreter "python2"))
(add-to-list 'interpreter-mode-alist '("python2" . python-mode))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'python-mode-hook
          '(lambda ()
             (setq tab-width 4
                   python-skeleton-autoinsert t
                   gud-pdb-command-name "python -m pdb ")))
#+end_src

The Python documentation used to be distributed in texinfo format. It
is not the case anymore since the documentation is handled by the
Sphinx framework. But it is still possible to generate texinfo files
using Sphinx; Such files are easy to find on the web (if you don't
want to generate them by yourself...). The =info-look= setting for
=python-mode= must be updated to those new files.

#+begin_src emacs-lisp :tangle .emacs
(eval-after-load "info-look" 
  '(info-lookup-add-help
    :mode 'python-mode
    :regexp "[[:alnum:]_]+"
    :doc-spec '(("(python)Index" nil ""))))
#+end_src

**** TODO Customize semantic include path			   :noexport:

Python mode hook must be enhanced with a dynamic customization of the
semantic include path.

#+begin_src emacs-lisp
(let* ((path ....))	; depends on version, os type and virtualenv
  (eval-after-load "wisent/python"
     (setq semantic-python-dependency-system-include-path path)))
#+end_src

Dynamic read of import path (regexp must be fixed):
#+begin_src emacs-lisp
(setq toto 
      (let ((cmd python-command))
	(shell-command-to-string
	 (concat cmd " -c \"from sys import path;\
path.remove(''); print path\""))))

(split-string toto "(\\['|', '|'\\]\n)")
#+end_src

**** TODO A word about virtualenv				   :noexport:

** Support for Scheme

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'scheme-mode-hook
	  '(lambda ()
	     (setq scheme-program-name "umb-scheme")))
#+end_src

* Text edition

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'text-mode-hook
	  '(lambda ()
	     (setq sentence-end 
		   "[.?!]\\($\\| $\\|	\\| \\)[ 	\n]*"
		   sentence-end-double-space nil)
 	     (auto-fill-mode 1)
	     (goto-address)
	     (use-hard-newlines 1 'never)
	     ;; (local-set-key "\C-c["
	     ;;   '(lambda () 
	     ;; 	  (interactive)
	     ;; 	  (require 'reftex)
	     ;; 	  (let ((reftex-cite-format 'locally)) 
	     ;; 	    (reftex-citation))))
	     (local-set-key [?\C-\M-$] 'ispell-buffer)
	     (defun alt-dbw ()
	       "Delete backward one space character if possible."
	       (when (eq (char-syntax (char-before)) ?\ ) 
		 (backward-delete-char 1)))
;;; 	     (local-set-key "?" 
;;; 	       '(lambda () 
;;; 		  (interactive)
;;; 		  (let ((skeleton-end-newline nil))
;;; 			    (skeleton-insert '(nil (alt-dbw) & ?Â ??)))))
;;; 	     (local-set-key "!"
;;; 	       '(lambda ()
;;; 		  (interactive)
;;; 		  	  (let ((skeleton-end-newline nil))
;;; 			    (skeleton-insert '(nil (alt-dbw) & ?Â ?!)))))
;;; 	     (local-set-key ";"
;;; 	       '(lambda ()
;;; 		  (interactive)
;;; 		  (let ((skeleton-end-newline nil))
;;; 		    (skeleton-insert '(nil (alt-dbw) & ?Â ?\;)))))
;;; 	     (local-set-key ":"
;;; 	       '(lambda ()
;;; 		  (interactive)
;;; 		  (let ((skeleton-end-newline nil))
;;; 		    (skeleton-insert '(nil (alt-dbw) & ?Â ?:)))))
	     ))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defun alt-fill-nobreak-predicate ()
  "Disable the breaking of current line.

This function is to be called during filling, with no arguments and with
point located at the place where a break is being considered. If the
function returns non-`nil', then the line won't be broken there."
  (save-match-data                 
    (or (looking-at "[ \t]*[])}»!?;:]")
	(save-excursion
	  (skip-chars-backward "« \t")
	  (backward-char 1)
	  (looking-at "[([{]")))))
#+end_src

** Support for SGML, HTML

It is difficult to avoid long lines when writing SGML files, thus
automatic line breaking is turned off.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'html-mode-hook
          '(lambda ()
             (auto-fill-mode -1)))
#+end_src

** Support for TeX and LaTeX

When a file with =.tex= extension is opened, it is parsed to identify
if it is a TeX or a LaTeX file. The latter will be the default if the
parsing fails to identify whether it is a TeX or a LaTeX file. Next,
the list of regions to be skipped while spell checking a buffer in TeX
mode is extended (most of the time =\ref= and =\label= parameters are
acronyms not recognized by the spell checker).

#+begin_src emacs-lisp :tangle .emacs
(setq tex-default-mode 'latex-mode)
(setq ispell-tex-skip-alists
      (cons
       (let ((list (car ispell-tex-skip-alists)))
	 (add-to-list 'list '("\\\\\\(ref\\|label\\)" ispell-tex-arg-end)))
       (cdr ispell-tex-skip-alists)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(setq latex-run-command "latex -src-specials -interaction=nonstopmode")
(add-hook 'latex-mode-hook
	  '(lambda ()
	     (setq comment-style 'plain
		   comment-column 0
		   indent-tabs-mode nil
		   ispell-check-comments nil
		   tex-trailer "\\end{document}"
		   latex-block-default "theorem"
		   latex-block-names
		   '("theorem" "proposition" "definition" "lemma" "multline")
		   tex-open-quote "\\og "
		   tex-close-quote "\\fg"
		   tex-alt-dvi-view-command
		   `(let ((line (count-lines 1 (point)))
			  (source (file-name-nondirectory (buffer-file-name))))
		      (concat "xdvi -sourceposition " 
			      (number-to-string line) source " *")))
	     (define-skeleton alt-latex-math-env
	       "Create a matching pair of parenthesis."
	       nil 92 40 _ 92 41)
	     (define-skeleton alt-latex-displaymath-env
	       "Create a matching pair of brackets."
	       nil 92 91 _ 92 93)
 	     (when input-method-alist
	       (activate-input-method "latin-1-prefix"))
	     (add-to-list 'tex-compile-commands
			  '("xdg-open %r.pdf &" "%r.pdf"))
	     (reftex-mode t)
	     (outline-minor-mode 1)
	     (define-key latex-mode-map [M-tab] 'info-complete-symbol)
	     (define-key latex-mode-map "\C-c\C-s" 'alt-latex-section)
	     (define-key latex-mode-map "\C-cm" 'alt-latex-math-env)
	     (define-key latex-mode-map "\C-cM" 'alt-latex-displaymath-env)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'tex-shell-hook
	  '(lambda ()
	     (add-to-list 'shell-font-lock-keywords
		    '("^\\(LaTeX Warning:\\|\\!\\)" . font-lock-warning-face))
	     (define-key tex-shell-map "\C-c\C-p" 'comint-previous-prompt)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defun alt-auto-insert-latex ()
  "Ask the user for a LaTeX class and a language name, then
insert the corresponding template file in current buffer.

The relative name of the template file is LaTeX/CLASS-LANG.tex or
LaTeX/CLASS.tex if language is empty. This file is taken in the
directory `auto-insert-directory'.

If class is empty, the current buffer is expected to belong to a
multi-file document; The user is asked for the name of the main
document, then a skeleton with a reference to that name is
inserted."
  (let* ((class (completing-read "Document class: "
				 '(("article" 1) ("report" 2) ("book" 3)
				   ("letter" 4) ("slides" 5) ("exam" 6))))
	 (lang (when (not (equal class ""))
		 (completing-read "Main language: "
				  '(("french" 1) ("english" 2))))))
    (if (not (equal class ""))
	(let ((name (expand-file-name 
		     (concat auto-insert-directory "LaTeX/" class
			     (when (not (equal lang "")) 
			       (concat "-" lang)) ".tex"))))
	  (if (file-readable-p name)
	      (progn
		(insert "% Time-stamp: <" (current-time-string)
			" " (user-login-name) ">\n% Author: "
			(user-full-name) " <" (progn user-mail-address) ">\n\n")
		(insert-file-contents name))
	    (message "No template file %s found" name)))
      (let ((name (read-file-name "Main file: " default-directory "")))
	(insert "% Time-stamp: <" (current-time-string)
		" " (user-login-name) ">\n% Author: " (user-full-name)
		" <" (progn user-mail-address) ">\n\n")
	(goto-char (point))
	(when (not (equal name ""))
	  (save-excursion
	    (insert "\n\n% Local Variables:\n% tex-main-file: \""
		    name "\"\n% End:\n")))))))

(add-to-list 'auto-insert-alist
	     '(latex-mode . alt-auto-insert-latex))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'reftex-mode-hook
	  '(lambda ()
	     (setq reftex-extra-bindings t
		   reftex-enable-partial-scans t
		   reftex-save-parse-info nil
		   reftex-use-multiple-selection-buffers t
		   reftex-label-alist
		   (setq reftex-label-alist
			 '(("theorem" ?h "thr:" "~\\ref{%s}" t 
			    (regexp "th\\\(\\\(é\\\|\'e\\\)or\\\(è\\\|\`e\\\)mes?\\\|m\\\.\\\)") nil)
			   ("proposition" ?p "pro:" "~\\ref{%s}" t 
			    (regexp "prop\\\(ositions?\\\|.\\\)") nil)
			   ("lemma" ?l "lem:" "~\\ref{%s}" t 
			    (regexp "lem\\\(mes?\\\|.\\\)") nil)
			   ("equation" 101 "eq:" "~(\\ref{%s})" t
			    (regexp "\\\(l'\\\)?\\\(é\\\|\'e\\\)quations?") nil)
			   ("example" ?x "exm:" "~\\ref{%s}" t 
			    (regexp "exemp\\\(les?\\\|.\\\)")))))
	     (defun reftex-page-reference ()
	       "Make a LaTeX reference to a page number."
	       (interactive)
	       (let ((reftex-format-ref-function
		      `(lambda (label format)
			 (concat "~\\pageref{" label "}"))))
		 (reftex-reference)))
	     (define-key reftex-mode-map "\C-c]" 'reftex-page-reference)
	     (define-key-after reftex-mode-menu [pageref]
	       '(menu-item "\\pageref" reftex-page-reference) '\\cite)))

(eval-after-load "reftex"
  '(let ((dir (expand-file-name "~/Documents/Mathématiques/Bibliographie")))
     (when (file-exists-p dir)
       (dolist (name (directory-files dir t ".*\.bib$"))
	 (add-to-list 'reftex-default-bibliography name)))))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defcustom latex-outline-max-level 4
  "Maximum level of outline headings used by imenu."
  :type 'integer
  :group 'tex)
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defadvice latex-imenu-create-index (before cut-section-alist activate)
  "Cut `latex-section-alist' to have max `latex-outline-max-level' in
`imenu' menu."
  (setq temp-latex-section-alist latex-section-alist)
  (set (make-local-variable 'latex-section-alist)
       (let (list)
	 (dolist (elt (default-value 'latex-section-alist))
	   (if (<= (cdr elt) latex-outline-max-level)
	       (push elt list)))
	 list)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defadvice latex-imenu-create-index (before cut-metasection-list activate)
  "Cut `latex-metasection-alist' to get rid of \\end{document} entries
in `imenu' menu."
  (setq temp-latex-metasection-list latex-metasection-list)
  (set (make-local-variable 'latex-metasection-list)
       (remove "end{document}" latex-metasection-list)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defadvice latex-imenu-create-index 
  (after restore-latex-metasection-list activate)
  "Restore `latex-metasection-list' default value."
  (setq latex-metasection-list temp-latex-metasection-list))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defadvice latex-imenu-create-index 
  (after restore-latex-section-alist activate)
  "Restore `latex-section-alist' default value."
  (setq latex-section-alist temp-latex-section-alist))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defvar tex-alt-dvi-view-command nil)

(defun alt-tex-view (&optional alt)
  "Like \\[tex-view] but allows use of alternative command.

If prefix argument is provided, use the alternative command,
`tex-alt-dvi-view-command'."
  (interactive "P")
  (or tex-dvi-view-command
      (error "You must set `tex-dvi-view-command'"))
  (let ((tex-dvi-print-command
	 (if alt tex-alt-dvi-view-command
	   tex-dvi-view-command)))
    (tex-print)))

(defvar alt-latex-section-default "paragraph")

(define-skeleton alt-latex-section
  "Create a sectionning command \\SECTION{TITLE} at point."
  (let ((section (completing-read 
		  (format "LaTeX section name [%s]: " 
			  alt-latex-section-default)
		  latex-section-alist nil nil nil nil 
		  alt-latex-section-default)))
    (setq alt-latex-section-default section))
  \n "\\" str ?\{ (skeleton-read "Title: ") ?\} \n \n)
#+end_src
* File management

** Replace deletion by move to trash

#+begin_src emacs-lisp :tangle .emacs
(setq delete-by-moving-to-trash t)
#+end_src

** Jumping and viewing

#+begin_src emacs-lisp :tangle .emacs
(autoload 'dired-jump "dired" "\
     Jump to Dired buffer corresponding to current buffer.
     If in a file, Dired the current directory and move to file's line.
     If in Dired already, pop up a level and goto old directory's line.
     In case the proper Dired file line cannot be found, refresh the Dired
     buffer and try again." t nil)

(autoload 'dired-jump-other-window "dired" "\
     Like \\[dired-jump] (dired-jump) but in other window." t nil) 

(define-key ctl-x-map "\C-j" 'dired-jump)

(define-key ctl-x-4-map "\C-j" 'dired-jump-other-window)
(define-key ctl-x-4-map "v" 'view-file-other-window)

(define-key ctl-x-5-map "v" 'view-file-other-frame)
(define-key ctl-x-5-map "c" 'alt-clone-indirect-buffer-other-frame)
#+end_src

** Enhancing file manager

#+begin_src emacs-lisp :tangle .emacs
(require 'dired-x)
(add-hook 'dired-load-hook
	  '(lambda ()
             (load-library "dired-x")
	     (setq dired-x-hands-off-my-keys nil)
             (dired-bind-find-file)
	     (setq dired-free-space-args "-Pk"
		   dired-listing-switches "-al")
	     (setq dired-isearch-filenames t)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(when (locate-library "gnus-dired")
  (require 'gnus-dired))
(setq dired-omit-files
      (concat dired-omit-files
	      "\\|^\\..+\\|^CVS$\\|^lost\\+found")
      dired-omit-extensions (delete ".pdf" dired-omit-extensions))
(add-hook 'dired-mode-hook
	  '(lambda ()
	     (when (fboundp 'gnus-dired-mode)
	       (gnus-dired-mode 1))
	     (setq dired-omit-files-p t
		   dired-omit-size-limit nil
		   truncate-lines t)
	     (set (make-local-variable 'transient-mark-mode) nil)
	     (define-key dired-mode-map "w" 'dired-copy-filename-as-kill)))
#+end_src

* Mail, newsgroup, RSS

** Usenet, RSS and electronic mail

I use Gnus for Usenet forums, RSS feeds and electronic mail. All
configuration files goes into =~/.emacs.d=.

#+begin_src emacs-lisp :tangle .emacs
(setq read-mail-command 'gnus
      mail-user-agent 'gnus-user-agent
      message-directory (expand-file-name "~/.emacs.d/Mail")
      gnus-home-directory (expand-file-name "~/.emacs.d/"))

(add-hook 'kill-emacs-hook
	  '(lambda ()
	     (when (and (fboundp 'gnus-alive-p) (gnus-alive-p))
	       (gnus-group-exit))))
#+end_src

** Message writing

#+begin_src emacs-lisp :tangle .emacs
(require 'message)
(add-hook 'message-mode-hook
	  '(lambda ()
	     (setq message-elide-ellipsis "\n> (...)\n"
		   message-signature t) 
	     (setq message-completion-alist
		   '(("^\\(Newsgroups\\|Followup-To\\|Posted-To\\|Gcc\\):" . message-expand-group)
		     ("^\\(Resent-\\)?\\(To\\|B?Cc\\):" . eudc-expand-inline)
		     ("^\\(Reply-To\\|From\\|Mail-Followup-To\\|Mail-Copies-To\\):" . eudc-expand-inline)
		     ("^\\(Disposition-Notification-To\\|Return-Receipt-To\\):" . message-expand-name)))
	     (setq ispell-message-dictionary-alist
		   '(("^To:[^\n,]+\\.fr[ \t\n,>]" . "francais")
		     ("^Newsgroups:[ \t]*fr\\." . "francais")
		     ("^Newsgroups:[ \t]*[^f]" . "english")))))
#+end_src

* Code sources 							   :noexport:

#+name: .emacs_header
#+begin_src emacs-lisp
;;; -*- coding: utf-8; -*-
;;; GNU Emacs Startup file

;;; WARNING This file was automatically generated: Do not edit
#+end_src

#+name: .emacs_custom-file_loading
#+begin_src emacs-lisp :tangle .emacs
(require 'cus-edit)
(setq custom-file (expand-file-name 
                   (concat  "~/.emacs.d/" system-name "-custom.el")))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src
   
#+name: .emacs_system-name_loading
#+begin_src emacs-lisp :tangle .emacs
(let ((file (locate-library (concat (system-name) ".el"))))
  (if file
      (load file t)
    (message "No machine specific initialization")))
#+end_src


