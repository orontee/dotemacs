An Emacs configuration tour

#+startup: overview
#+language: en
#+drawers: PROPERTIES FEEDSTATUS
#+filetags: emacs
#+todo: TODO | DONE CANCELED
#+style: <link rel="stylesheet" type="text/css" href="css/clean.css" />
#+options: H:2 toc:nil todo:t email:t ^:nil

* Introduction

I am using [[http://www.gnu.org/software/emacs/][GNU Emacs]] since the late '90 on various environments, both
at home or at work. At the beginning, I used it to write LaTeX files:
I found that tool more or less randomly while sitting in front of one
of the X Window terminals of my university. Today, whatever I have to
do with a computer, it ends in an Emacs buffer... In my current use,
Emacs has become a kind of interface over the computer's operating
system (whatever it is: Arch Linux, Ubuntu, Windows XP, Vista and 10).
But suprisingly I feel like it has adapt to my needs rather than I
have limited myself to its features.

As an intensive Emacs user I had various needs related to Emacs
customization: Centralize all customization to be able to deploy
efficiently on multiple targets; Organize Emacs customization in the
order demanded by the flow of my needs rather than the one imposed by
the computer; Share Emacs customization; Gather links to external
tools; Log my contributions; Etc. Thus I have written an Org file
whose code blocks could be converted to the source file I use to
customize Emacs to my needs and, on the other hand, is the source of
the documentation you are reading.

*Downloads*

You can download this [[file:README.org][Org file]] and build the corresponding =init.el= using
=org-babel-tangle=, or simply clone this repository and use =GNU Make=
to build that file.

*References*

Most of the following code snippets I have written myself. Some were
copied from the [[https://lists.gnu.org/mailman/listinfo/help-gnu-emacs][gnu.emacs.help newsgroup]] or the [[http://www.emacswiki.org/][Emacs wiki]].

* General use
** Header                                                          :noexport:

#+begin_src emacs-lisp :tangle init.el :noweb tangle
<<init.el_header>>
#+end_src

** Checking emacs version

Despite a common misconception, GNU Emacs is actively maintained and
last versions were greatly improved. A recent version is required. It
can be downloaded from http://ftp.gnu.org/pub/gnu/emacs/.

#+begin_src emacs-lisp :tangle init.el
(when (or (< emacs-major-version 24)
          (and (= emacs-major-version 24)
               (< emacs-minor-version 3)))
  (error "Wrong Emacs version, update or remove the configuration
  file"))
#+end_src

I usually build my own binary from a Git repository.

#+begin_src sh
    $ ./autogen.sh
    $ ./configure --with-pgtk --no-create --no-recursion --prefix=/opt/emacs
    $ CFLAGS='-O3' make -j 10 bootstrap
    $ make
    $ sudo make install
    $ sudo update-alternatives \
      --install /usr/bin/emacs emacs \
                /usr/local/bin/emacs 99 \
      --slave /usr/share/man/man1/emacs.1.gz emacs.1.gz \
              /usr/local/share/man/man1/emacs.1.gz
    $ sudo update-alternatives \
      --install /usr/bin/emacsclient emacsclient \
                /usr/local/bin/emacsclient 99 \
      --slave /usr/share/man/man1/emacsclient.1.gz emacsclient.1.gz \
              /usr/local/share/man/man1/emacsclient.1.gz
#+end_src

** Extending Emacs, packages repositories, etc

The easiest way to extend Emacs features is to use =list-package= and
install packages from remote repositories. But =package.el= is rather
new and not all libraries are available in the form of packages. When
a library must be installed by hand, a good practice is to always put
it in the directory =~/.config/emacs/lisp=. The load path is extended
accordingly.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'load-path (expand-file-name "~/.config/emacs/lisp/"))
#+end_src

The default is to fetch packages from the GNU Emacs packages
repository. There are usefull packages in other places like [[http://tromey.com/elpa/][ELPA]] and
[[http://marmalade-repo.org/][Marmalade]].

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load "package"
  (add-to-list 'package-archives '("melpa". "https://melpa.org/packages/")))
#+end_src

At the time of writing, I have activated the following packages:

#+begin_src emacs-lisp :exports results :results value raw
(let ((descriptions "|Package|Description|\n|---|\n"))
  (dolist (package (sort package-alist) descriptions)
    (let ((name (car package))
          (desc (package-desc-summary (cadr package))))
    (setq descriptions
          (concat descriptions (format "|%s|%s|\n" name desc))))))
#+end_src

#+RESULTS:
| Package            | Description                                                 |
|--------------------+-------------------------------------------------------------|
| CMake-doc          | Info documentation for CMake                                |
| Python-doc         | Info documentation for Python                               |
| adoc-mode          | a major-mode for editing AsciiDoc files                     |
| bitbake-modes      | Major modes for editing bitbake bb* and conf files.         |
| breadcrumb         | project and imenu-based breadcrumb paths                    |
| capnp-mode         | Major mode for editing Capn' Proto Files                    |
| cmake-mode         | Major-mode for editing CMake sources.                       |
| corfu              | COmpletion in Region FUnction                               |
| csv-mode           | Major mode for editing comma/char separated values          |
| devicetree-ts-mode | Tree-sitter support for DTS                                 |
| diminish           | Diminished modes are minor modes with no modeline display   |
| edit-indirect      | Edit regions in separate buffers                            |
| eglot              | The Emacs Client for LSP servers                            |
| feature-mode       | Major mode for editing Gherkin (i.e. Cucumber) user stories |
| git-link           | No description available.                                   |
| gptel              | Interact with ChatGPT or other LLMs                         |
| guess-language     | Robust automatic language detection                         |
| jsonrpc            | JSON-RPC library                                            |
| marginalia         | Enrich existing commands with completion annotations        |
| markdown-mode      | Major mode for Markdown-formatted text                      |
| mermaid-mode       | Major mode for working with mermaid graphs.                 |
| mermaid-ts-mode    | Major mode for Mermaid                                      |
| meson-mode         | Major mode for the Meson build system files.                |
| minimap            | Sidebar showing a "mini-map" of a buffer                    |
| mmm-mode           | Allow Multiple Major Modes in a buffer                      |
| modus-themes       | Elegant, highly legible and customizable themes             |
| nsis-mode          | NSIS-mode.                                                  |
| pdf-tools          | Support library for PDF documents                           |
| powershell         | Mode for editing PowerShell scripts                         |
| pulsar             | Pulse highlight on demand or after select functions         |
| qt-pro-mode        | Qt Pro/Pri major mode                                       |
| rainbow-mode       | Colorize color names in buffers                             |
| restclient         | No description available.                                   |
| sops               | SOPS encrypt and decrypt without leaving the editor.        |
| spacious-padding   | Increase the padding/spacing of frames and windows          |
| ssass-mode         | Edit Sass without a Turing Machine                          |
| structurizr-mode   | No description available.                                   |
| systemd            | Major mode for editing systemd units                        |
| tablist            | Extended tabulated-list-mode.                               |
| vue-html-mode      | Major mode for editing Vue.js templates                     |
| vue-mode           | Major mode for vue component based on mmm-mode              |
| x509-mode          | View certificates, CRLs and keys using OpenSSL.             |


All settings written using the customize library go to a dedicated
file that is loaded when the loading of the [[file:.init.el][configuration file]] ends.

#+begin_src emacs-lisp :noweb yes
<<init.el_custom-file_loading>>
#+end_src

When the custom settings are loaded, a machine specific file is
loaded. The file name comes from the host name of the machine Emacs is
running on.

#+begin_src emacs-lisp :noweb yes
<<init.el_system-name_loading>>
#+end_src

** Widening the screen

You feel like the computer screen is too narrow, don't you? So menu
bars, scroll bars and tool bars must be disabled. Whats more,
disabling this eyecandy may improve responsiveness when Emacs run on a
remote computer forwarding X11. Note that the content of the menu bar
is still available by pressing =f10= or the contextual menu bind to
=C-mouse-1=.

#+begin_src emacs-lisp :tangle init.el
(when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(when (fboundp 'horizontal-scroll-bar-mode) (horizontal-scroll-bar-mode -1))
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+end_src

Don't know how to scroll buffers now that the scrollbar is gone? Read
the descriptions of the following key bindings: =M-v=, =C-v=, =M-C-v=,
=S-M-C-v=, =C-l=, =C-M-l=, =<prior>=, =<next>=, etc. Why should we add
scrollbars? By the way, the mode line indicates the percentage of the
buffer above the top of the window. And the column number is available
from the output of =C-x== (bind to =what-cursor-position=).

Another way to widen the screen is to truncate long lines and change
the text scale in secondary buffers. Restoring or changing the text
scale can be done interactively with =C-xC-0=, =C-xC-+= and =C-xC-=.

#+begin_src emacs-lisp :tangle init.el
  (when (require 'face-remap)
    (dolist (hook '(apropos-mode-hook
                    gdb-breakpoints-mode-hook
                    gdb-frames-mode-hook
                    gdb-inferior-io-mode-hook
                    gdb-locals-mode-hook
                    vc-dir-mode-hook
                    log-view-mode-hook
                    xref--xref-buffer-mode-hook
                    flymake-diagnostics-buffer-mode-hook
                    gdb-mode-hook
                    grep-mode-hook
                    occur-mode-hook
                    speedbar-mode-hook))
      (add-hook hook
                (lambda ()
                  (setq truncate-lines t)
                  (when (not text-scale-mode)
                    (text-scale-set -1))))))
  (add-hook 'compilation-mode-hook
    (lambda ()
      (when (not text-scale-mode)
        (text-scale-set -1))))
#+end_src

I also like to have a clear mode line. Most of the time the minor
modes indicators don't bring much information and I prefer to remove
them:
#+begin_src emacs-lisp :tangle init.el
(setq flyspell-mode-line-string nil)
(when (locate-library "which-key")
  (load-library "which-key")
  (setq which-key-lighter ""))
#+end_src

Diminish mode-line display of minor modes.

#+begin_src emacs-lisp :tangle init.el
(when (locate-library "diminish")
  (require 'diminish)
  (diminish 'completion-preview-mode)
  (diminish 'eldoc-mode)
  (diminish 'abbrev-mode))
#+end_src

Hide title bar when window is maximized.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'window-size-change-functions
            #'frame-hide-title-bar-when-maximized)
#+end_src

** Bookmarks

Lighter bookmark menu: Filenames are hidden and more horizontal space
is dedicated to bookmark names.

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load "bookmark"
  (setq bookmark-bmenu-file-column 60
        bookmark-bmenu-toggle-filenames nil))
#+end_src

Completion of bookmark name uses substring style.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'completion-category-overrides '(bookmark (styles substring)))
#+end_src

** Buffers

Keybindings to view differences between a buffer and the underlying
file.

#+begin_src emacs-lisp :tangle init.el
  (defun diff-with-file ()
    (interactive)
    (let* ((buf (current-buffer))
  	 (file (buffer-file-name buf)))
      (when (not file) (error "Specified buffer has no file"))
      (diff-buffer-with-file)))

  (keymap-set ctl-x-x-map "=" 'diff-with-file)

  (defun buffer-menu-view-differences ()
    (interactive nil Buffer-menu-mode)
    (let* ((buf (Buffer-menu-buffer t))
  	 (file (buffer-file-name buf)))
      (cond
       ((not file) (error "Specified buffer has no file"))
       ((and buf (with-current-buffer buf
                   (diff-buffer-with-file)))))))

  (keymap-set Buffer-menu-mode-map "=" 'buffer-menu-view-differences)
#+end_src

** Remember

I used to use Org mode (this buffer!). But nowadays I prefer to stick
to the universal Markdown or ReStructuredText formats.

Thus I add to find an alternative for "Org capture" and just switched
to good old "Remember mode" to remember data.

Notes are appended to a dedicated remember data file in Markdown mode,
with a date tag and a properly formatted link to buffer file.

#+begin_src emacs-lisp :tangle init.el
  (defun markdown-buffer-file-name-as-link (&optional buffer)
    "Return link to file BUFFER is visiting, or nil if none."
    (let ((buffer (get-buffer (or buffer (current-buffer)))))
      (let* ((buffer (or (buffer-base-buffer buffer) buffer))
             (filepath (buffer-file-name buffer))
             (name (buffer-name buffer)))
        (when filepath
          (concat "[" name "]("
                  (url-encode-url (concat "file://" filepath))
                  ")")))))

  (defun markdown-insert-buffer-file-link (buffer)
    "Insert link to file visited by BUFFER."
    (interactive "bBuffer: ")
    (let ((link (markdown-buffer-file-name-as-link buffer)))
      (if link
  	(insert link)
        (message "Buffer not visiting a file"))))

  (defun markdown-date-tag (format-string)
    "Return date tag."
    (concat "[date]:# \"" (format-time-string format-string) "\""))

  (defun markdown-insert-date-tag (&optional format-string)
    "Insert a date tag.
    Use FORMAT-STRING as format, see `format-time-string'; Default to the
    locale's date and time format."
    (interactive)
    (insert (markdown-date-tag (or format-string "%c"))))

  (defvar remember-markdown-title-level 2)

  (require 'remember)
  (defun remember-markdown-format-note (text)
    "Meant to be used with `remember-text-format-function'.
    It returns the text to be remembered, formatted as a Markdown section of
    level `remember-markdown-title-level'."
    (let ((desc (remember-buffer-desc)))
      (with-temp-buffer
        (markdown-insert-header remember-markdown-title-level desc)
        (end-of-line)
        (insert (concat "\n"
                        (markdown-date-tag remember-time-format) "\n\n"
                        text))
        (buffer-string))))

  (defvar remember-data-files-regex "\\.md\\'")

  (defun remember-append-in-data-directory ()
    "Append remember data to a file in `remember-data-directory'.
  The file is read from minibuffer."
    (let* ((name
  	 (completing-read "Remember in file: "
  			  (directory-files
  			   (expand-file-name remember-data-directory)
  			   nil
  			   remember-data-files-regex)))
          (remember-data-file (expand-file-name name remember-data-directory)))
      (remember-append-to-file)))

  (defvar remember-markdown-archive-file "~/Documents/Notes/Archives.md")

  (defun remember-markdown-archive-note ()
    "Archive current note.
  The note is moved to `remembre-markdown-archive-file'."
    (interactive)
    (when (markdown-heading-at-point)
      (next-line))
    (save-mark-and-excursion
      (markdown-kill-outline)
      (let ((buf (find-buffer-visiting remember-markdown-archive-file))
  	  (text (current-kill 0)))
        (if buf
  	  (with-current-buffer buf
  	    (goto-char (point-max))
  	    (insert text))
  	(append-to-file text nil remember-markdown-archive-file)))))

  (define-prefix-command 'remember-prefix-map)
  (keymap-global-set "C-x M-r" 'remember-prefix-map)
  (keymap-set remember-prefix-map "r" 'remember)
  (keymap-set remember-prefix-map "c" 'remember-clipboard)
  (keymap-set remember-prefix-map "R" 'remember-region)
  (keymap-set remember-prefix-map "n" 'remember-notes)

  (with-eval-after-load "remember"
  (define-derived-mode remember-mode markdown-mode "Remember"
    "Major mode for output from \\[remember].
  This buffer is used to collect data written in Markdown format that you
  want to remember.
  \\<remember-mode-map>
  Just hit \\[remember-finalize] when you're done entering, and it will file
  the data away for latter retrieval, and possible indexing.
  \\{remember-mode-map}"
    ;; restore Markdown mode keybindings overwritten in
    ;; remember-mode-map
    (keymap-local-set "C-c C-s" markdown-mode-style-map)

    (setq header-line-format
  	(substitute-command-keys
  	 "Edit, then exit with `\\[remember-finalize]' or abort with \
  `\\[remember-destroy]'")))

  (setq remember-notes-initial-major-mode 'markdown-mode
        remember-annotation-functions '(markdown-buffer-file-name-as-link)
        remember-handler-functions '(remember-append-in-data-directory)
        remember-data-directory "~/Documents/Notes"
        remember-data-file (expand-file-name "Remember.md"
      					   remember-data-directory)
        remember-text-format-function 'remember-markdown-format-note
        remember-time-format "%c"
        remember-leader-text nil))
#+end_src

** Generic modes

From the docstring: Generic modes provide basic comment and font-lock
functionality for "generic" files. (Files which are too small to
warrant their own mode, but have comment characters, keywords, and the
like.)

The file =generic-x.el= contains a collection of generic modes. The
default is to enable generic modes according to the host operating
system; I prefer to always define MS Windows generic modes for I
sometime have to work on script files for the MS Windows command
line...

#+begin_src emacs-lisp :tangle init.el
  (load "generic-x")
  (setq generic-extras-enable-list
        (append generic-default-modes
                generic-mswindows-modes
                generic-unix-modes))
  (load "generic-x")
#+end_src

The =systemd= configuration files are Conf files.

#+begin_src emacs-lisp :tangle init.el
(when (eq system-type 'gnu/linux)
  (add-to-list 'auto-mode-alist
               '("\\.service\\'" . conf-mode)))
#+end_src

Bind =rc-generic-mode= to Visual Studio Resource files.

#+begin_src emacs-lisp :tangle init.el
  (add-to-list 'auto-mode-alist
               '("\\.rc2\\'" . rc-generic-mode))
(add-to-list 'auto-mode-alist
             '("\\git-rebase-todo\\'" . default-generic-mode))
#+end_src

** Auto insertion at file creation

Auto insertion of templates at file creation is enabled and the
location where templates are searched is defined.

#+begin_src emacs-lisp :tangle init.el
(auto-insert-mode)
(let ((file (expand-file-name "~/Mod√®les")))
  (when (file-exists-p file)
    (setq auto-insert-directory file)))
#+end_src

** Revert buffers on file changes

Reverts any buffer associated with a file when the file changes on
disk. For files with =.log= extension, the tail is constantly
followed.

#+begin_src emacs-lisp :tangle init.el
(global-auto-revert-mode)

(add-hook 'find-file-hook
          (lambda()
             (when (and (buffer-file-name)
                        (equal (file-name-extension (buffer-file-name)) "log"))
               (auto-revert-tail-mode))))
#+end_src

** Handle long lines

#+begin_src emacs-lisp :tangle init.el
(global-so-long-mode 1)
#+end_src

To prevent long lines, enable display of the fill column indicator.

#+begin_src emacs-lisp :tangle init.el
(global-display-fill-column-indicator-mode t)
(setq global-display-fill-column-indicator-modes '((not special-mode) prog-mode))
#+end_src

** Moving between windows and selecting buffers

Usually the frame is split at most twice. I find =C-xo= sufficient to
change the selected window along the three candidates.

To select a buffer I often use =C-xb= and completion. When my brain
can't remember the buffer name, I use the default buffer menu
(accessible from =C-xC-b= and =C-uC-xC-b=).

Some side windows are identified, so their location is predictable and
I can get rid of all of them with a single =C-xws=!

#+begin_src emacs-lisp :tangle init.el
  (defvar side-windows-parameters
    '(window-parameters . ((no-other-window . nil)
                           (no-delete-other-windows . t))))

  (setq fit-window-to-buffer-horizontally t
        window-resize-pixelwise t
        window-sides-vertical nil)

  (defun toggle-side-windows-configuration ()
    (let ((fullscreen (frame-parameter (window-frame) 'fullscreen)))
      (if fullscreen
          (setq display-buffer-alist
                `(("\\*\\(?:xref\\|grep\\|Occur\\|Buffer List\\|Help\\)\\*"
                   display-buffer-in-side-window
                   (side . right) (slot . 0) (window-width . balance-windows)
                   (preserve-size . (nil . nil)) ,side-windows-parameters)
                  ("\\*\\(?:.+shell\\|compilation\\|Flymake.*\\)\\*"
                   display-buffer-in-side-window
                   (side . right) (slot . 1) (window-width . balance-windows)
  		 (preserve-size . (nil . nil)) ,side-windows-parameters))
                window-min-width 40)
        (setq display-buffer-alist nil
              window-min-width 10))))

  (add-hook 'window-state-change-hook
            'toggle-side-windows-configuration)
#+end_src

** Completion

The vanilla completion window is hidden if not explicitly asked
for. It has no modeline. And follows a horizontal layout.

#+begin_src emacs-lisp :tangle init.el
  (setq completions-detailed t
        completions-format 'horizontal
        completions-group t
        completions-max-height 15
        completions-sort 'historical
        completion-auto-select 'second-tab
        completion-auto-help t
        completion-show-help nil)

  (add-hook 'completion-list-mode-hook
            (lambda ()
              (setq-local mode-line-format nil)
              (setq truncate-lines t)))
#+end_src

Use =icomplete= for minibuffer completion.

#+begin_src emacs-lisp :tangle init.el
  (setq icomplete-in-buffer nil
        icomplete-show-matches-on-no-input t
        icomplete-tidy-shadowed-file-names t)
  (icomplete-mode 1)

  (when (locate-library "marginalia")
    (require 'marginalia)
    (setq marginalia-align 'right)
    (marginalia-mode 1))
#+end_src

When available, use =corfu= for completion in region.

#+begin_src emacs-lisp :tangle init.el
  (when (locate-library "corfu")
    (require 'corfu)
    (global-corfu-mode 1)
    (setq corfu-auto t))
#+end_src

When reading file or buffer names the case will be ignored.

#+begin_src emacs-lisp :tangle init.el
(setq read-file-name-completion-ignore-case t
      read-buffer-completion-ignore-case t)
#+end_src

** Cycling spacing

#+begin_src emacs-lisp :tangle init.el
(keymap-global-set "M-SPC" 'cycle-spacing)
#+end_src

** Empty scratch buffer

#+begin_src emacs-lisp :tangle init.el
(setq initial-scratch-message nil)
#+end_src

** Diary and calendar customization

A diary file is automatically created.

#+begin_src emacs-lisp :tangle init.el
(let ((file (expand-file-name "~/.config/emacs/diary")))
  (when (not (file-exists-p file))
    (write-region "" nil file))
  (setq diary-file file))
#+end_src

The calendar is configured to match the french standards.

#+begin_src emacs-lisp :tangle init.el
(setq european-calendar-style t
      calendar-time-display-form
      '(24-hours ":" minutes
                 (if time-zone " (") time-zone (if time-zone ")"))
      calendar-week-start-day 1
      calendar-intermonth-text
      '(propertize
        (format "%2d"
                (car
                 (calendar-iso-from-absolute
                  (calendar-absolute-from-gregorian (list month day year)))))
        'font-lock-face 'font-lock-function-name-face))

(setq view-diary-entries-initially t
      number-of-diary-entries [0 2 2 2 2 4 1]
      mark-diary-entries-in-calendar t
      view-calendar-holidays-initially nil
      mark-holidays-in-calendar t
      general-holidays nil
      hebrew-holidays nil
      all-christian-calendar-holidays t
      islamic-holidays nil
      oriental-holidays nil)

(add-hook 'today-visible-calendar-hook 'calendar-mark-today)

(add-hook 'diary-display-hook 'fancy-diary-display)
#+end_src

French holidays are be added to the calendar. Note that Christian
holidays are already present into the calendar since we have set
=all-christian-calendar-holidays= to =t=.

#+begin_src emacs-lisp :tangle init.el
(setq french-holiday
      '((holiday-fixed 1 1 "Jour de l'an")
        (holiday-fixed 5 1 "F√™te du travail")
        (holiday-fixed 5 8 "Victoire 1945")
        (holiday-fixed 7 14 "F√™te nationale")
        (holiday-fixed 11 1 "Toussaint")
        (holiday-fixed 11 11 "Armistice 1918")))

(setq holiday-other-holidays
      (append french-holiday holiday-other-holidays))
#+end_src

** Electric modes

Enable pairing to insert pairs of matching characters.

#+begin_src emacs-lisp :tangle init.el
(electric-pair-mode)
#+end_src

** Save place

Automatically save place of cursor in each file.

#+begin_src emacs-lisp :tangle init.el
(save-place-mode 1)
#+end_src

** Archives display

#+begin_src emacs-lisp :tangle init.el
(require 'tar-mode)
(setq tar-mode-show-date t)
#+end_src

** Time and date

When working in a console, it is sometime usefull to get the time:
=M-! date= is ok for this. To display the time in the modeline there
is =display-time-mode=.

#+begin_src emacs-lisp :tangle init.el
(require 'time)
(add-hook 'display-time-mode-hook
          (lambda ()
             (setq display-time-day-and-date nil
                   display-time-24hr-format t
                   display-time-use-mail-icon nil
                   display-time-format "%A,%e %B %Y %R")))
#+end_src

** Syntax highlighting

#+begin_src emacs-lisp :tangle init.el
(add-hook 'font-lock-mode-hook
          (lambda ()
             (show-paren-mode)))

(add-hook 'show-paren-mode-hook
          (lambda ()
             (setq show-paren-style 'parenthesis)))
#+end_src

** Final new line

All files will have a newline at their end.

#+begin_src emacs-lisp :tangle init.el
(setq require-final-newline t)
#+end_src

** Display settings

Group buffers by their major modes when using the contextual menu to
select a buffer.

#+begin_src emacs-lisp :tangle init.el
(context-menu-mode)
(with-eval-after-load "mouse"
  (setq mouse-buffer-menu-mode-mult 2)
  (add-to-list 'mouse-buffer-menu-mode-groups '("Dired" . "Dired"))
  (add-to-list 'mouse-buffer-menu-mode-groups '("tex" . "TeX/LaTeX")))
#+end_src

Highlight the current line and indicates buffer boundaries in table
based buffers and alike ones.

#+begin_src emacs-lisp :tangle init.el
  (dolist (hook '(tabulated-list-mode-hook
                  bookmark-bmenu-mode-hook
                  log-view-mode-hook))
    (add-hook hook
              (lambda ()
                (hl-line-mode)
                (setq indicate-buffer-boundaries
                      '((top . left) (bottom . right))))))
#+end_src

Silent bell.

#+begin_src emacs-lisp :tangle init.el
(setq visible-bell t)
#+end_src

Use pixel precision scrolling.

#+begin_src emacs-lisp :tangle init.el
(pixel-scroll-precision-mode)
(setq pixel-scroll-precision-large-scroll-height 40.0)
#+end_src

Outline minor mode uses in-margins buttons. An unhidden blank line is
kept before headings. And the =C-c @= key binding is defined to toggle
outline minor mode.

#+begin_src emacs-lisp :tangle init.el
(setq outline-minor-mode-use-buttons 'in-margins
      outline-blank-line t)

(define-prefix-command 'outline-minor-prefix-map)
(keymap-global-set "C-c @" 'outline-minor-prefix-map)
(keymap-set outline-minor-prefix-map "t" 'outline-minor-mode)
#+end_src

** Tab bar

I like tabs but want them to use the same keybindings as GTK-based
applications. Also I want new tabs to display bookmarks.

#+begin_src emacs-lisp :tangle init.el
(require 'bookmark)
(defun get-or-build-bookmark-buffer ()
  (cond
   ((get-buffer bookmark-bmenu-buffer))
   (t (save-excursion
        (save-window-excursion
          (bookmark-bmenu-list)
          (get-buffer bookmark-bmenu-buffer))))))

(when (featurep 'tab-bar)
  (setq tab-bar-close-button-show t
        tab-bar-close-last-tab-choice 'delete-frame
        tab-bar-close-tab-select 'left
        tab-bar-new-tab-choice 'get-or-build-bookmark-buffer
        tab-bar-select-tab-modifiers '(meta))
  (keymap-set tab-prefix-map "1" nil)
  (keymap-global-set "C-<next>" 'tab-bar-switch-to-next-tab)
  (keymap-global-set "C-<prior>" 'tab-bar-switch-to-prev-tab)
  (keymap-global-set "C-S-<next>" (lambda () (interactive) (tab-bar-move-tab 1)))
  (keymap-global-set "C-S-<prior>" (lambda () (interactive) (tab-bar-move-tab -1))))
#+end_src

** Frame customization definitions

#+begin_src emacs-lisp
(setq default-frame-alist
      '((menu-bar-lines . nil)
        (tool-bar-lines . nil)
        (vertical-scroll-bars . nil)
        (horizontal-scroll-bars . nil)
        (font . "Inconsolata-10")
        (cursor-color . "red3")))
#+end_src

For X Window frames, it is better to customize the [[file:~/.Xresources][resources file]]:

#+begin_src x-resource-generic-mode
! Emacs frame customization
Emacs.menuBar: off
Emacs.toolBar: off
Emacs.verticalScrollBars: off
Emacs.font: Inconsolata-10
Emacs
#+end_src

*** TODO Add the equivalent for MS Windows

** Documentation, help

Make local documentation available.

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'Info-mode-hook
            (lambda ()
               (setq truncate-lines t)))

  (let ((path (expand-file-name "~/.local/share/info/")))
    (when (file-accessible-directory-p path)
      (add-to-list 'Info-additional-directory-list path)))
#+end_src

Enable Which Key mode and make it use Unicode.

#+begin_src emacs-lisp :tangle init.el
  (when (locate-library "which-key")
    (require 'which-key)
    (setq which-key-dont-use-unicode nil)
    (which-key-mode 1))
#+end_src

** Tab bar

#+begin_src emacs-lisp :tangle init.el
  (setq tab-bar-close-button-show 'selected
        tab-bar-format
  	'(tab-bar-format-menu-bar tab-bar-format-history tab-bar-format-tabs
  				  tab-bar-separator)
  	tab-bar-show t)
#+end_src

** Server, daemon

A server is started if and only if the running process is not a daemon
and there is not already a server started. In that way the Emacs
client will always find someone to talk to.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'server-switch-hook 'raise-frame)

(load-library "server")
(when (not (or (server-running-p) (daemonp)))
  (server-start))
#+end_src

To have =emacsclient= called by =sudoedit=, =git= and other programs
when they are tell to edit a file, [[file:~/.bashrc][Bash configuration file]] contains
the following snippet:

#+begin_src shell-script-mode
builtin type -p emacsclient &>/dev/null
[ -n $@ ] && export EDITOR=emacsclient
#+end_src

I also define an [[file:~/.bash_aliases][Bash alias]] to launch Emacs in terminals:

#+begin_src shell-script-mode
function is_command { type "$1" &> /dev/null; }
is_command emacs      && alias     em='emacsclient -t'
#+end_src

*** TODO Windows equivalent

** Minibuffer history

#+begin_src emacs-lisp :tangle init.el
(savehist-mode)
#+end_src

** Theme

Apply Modus theme for accessible readability.

#+begin_src emacs-lisp :tangle init.el
  (require 'modus-themes)

  (defun personal-modus-themes-custom-faces ()
    (modus-themes-with-colors
      (custom-set-faces
       ;; variable pitch face in info headings
       `(info-title-1 ((,c :inherit info-title-2 :height 1.2 :foreground ,fg-heading-1)))
       `(info-title-2 ((,c :inherit info-title-3 :height 1.2 :foreground ,fg-heading-2)))
       `(info-title-3 ((,c :inherit info-title-4 :height 1.2 :foreground ,fg-heading-3)))
       `(info-title-4 ((,c :inherit (bold variable-pitch) :height 1.0 :foreground ,fg-heading-4)))
       ;; variable pitch face in markdown headings
       `(markdown-header-face-1 ((,c :inherit markdown-header-face-2 :height 1.2 :foreground ,fg-heading-1)))
       `(markdown-header-face-2 ((,c :inherit markdown-header-face-3 :height 1.2 :foreground ,fg-heading-2)))
       `(markdown-header-face-3 ((,c :inherit markdown-header-face-4 :height 1.2 :foreground ,fg-heading-3)))
       `(markdown-header-face-4 ((,c :inherit (bold variable-pitch) :height 1.0 :foreground ,fg-heading-4)))
       ;; lighter fill column indicator
       `(fill-column-indicator ((,c :background ,bg-dim)))
       ;; smaller line numbers
       `(line-number  ((,c :inherit default :height 0.8 :foreground ,fg-dim))))))

  (setq modus-themes-variable-pitch-ui t
        modus-themes-to-toggle '(modus-operandi-tinted modus-vivendi-tinted))

  (add-hook 'modus-themes-after-load-theme-hook #'personal-modus-themes-custom-faces)

  (load-theme 'modus-vivendi-tinted :no-confirm)
  (personal-modus-themes-custom-faces)
#+end_src

Spacious padding make the UI even more readable.

#+begin_src emacs-lisp :tangle init.el
  (when (locate-library "spacious-padding")
    (require 'spacious-padding)

    (defun my-custom-faces-after-spacious-padding (&rest _)
      "Set face attributes after `spacious-padding-mode'.
  Add this to the `spacious-padding-mode-hook'."
      ;; Add more `set-face-attribute' calls here
      (set-face-attribute 'line-number nil :height 0.8))

    (add-hook 'spacious-padding-mode-hook #'my-custom-faces-after-spacious-padding)
    (add-hook 'after-make-frame-functions #'my-custom-faces-after-spacious-padding)

    (spacious-padding-mode))
#+end_src

** Persistence

Save Emacs state from one session to another.

#+begin_src emacs-lisp :tangle init.el
  (setq desktop-restore-frames nil
        desktop-restore-eager 1
        desktop-lazy-verbose nil
        desktop-buffers-not-to-save "\\` \\|\\*eww\\*")

  (with-eval-after-load "desktop"
    (add-to-list 'desktop-modes-not-to-save 'tar-mode)
    (add-to-list 'desktop-modes-not-to-save 'archive-mode))

  (setq desktop-buffers-not-to-save-function
        (lambda (_filename bufname &rest _)
  	(cond
  	 ((> (buffer-size (get-buffer bufname))
  	     (expt 2 20))
  	  nil)
  	 (t))))

  (desktop-save-mode)
#+end_src

** Various

Tired of typing =yes= and =no=? Prefer =y= and =n=!

#+begin_src emacs-lisp :tangle init.el
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

These are some core features disabled for newbies.

#+begin_src emacs-lisp :tangle init.el
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'scroll-left 'disabled nil)
#+end_src

Extend automatic selection of mode based on file name.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'auto-mode-alist '("PKGBUILD\\'" . sh-mode))
(add-to-list 'auto-mode-alist '("\\.yaml\\'" . yaml-ts-mode))
#+end_src

Extend executable path.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'exec-path (expand-file-name "~/.local/bin"))
#+end_src

Display current working directory in `shell-command` and
`async-shell-command`.
#+begin_src emacs-lisp :tangle init.el
(setq shell-command-prompt-show-cwd t)
#+end_src

Use single character to indicate string truncation.

#+begin_src emacs-lisp :tangle init.el
(setq truncate-string-ellipsis "‚Ä¶")
#+end_src

Prefer tree-sitter based modes.

#+begin_src emacs-lisp :tangle init.el
  (setq major-mode-remap-alist
        '((sh-mode . bash-ts-mode)
          (c++-mode . c++-ts-mode)
          (c-mode . c-ts-mode)
          (css-mode . css-ts-mode)
          (js-mode . js-ts-mode)
  	(javascript-mode . js-ts-mode)
          (json-mode . json-ts-mode)
          (python-mode . python-ts-mode)
          (typescript-mode . typescript-ts-mode)
          (yaml-mode . yaml-ts-mode)))
#+end_src

Set proper keyboard layout to generate up-to-date transient input
method descriptions.

#+begin_src emacs-lisp :tangle init.el
  (with-eval-after-load "quail"
    (add-to-list 'quail-keyboard-layout-alist
                 '("pc105-fr" . "                                &1√©2\"3'4(5-6√®7_8√ß9√†0)¬∞=+      aAzZeErRtTyYuUiIoOpP^\"$¬£      qQsSdDfFgGhHjJkKlLmM√π%*¬µ      <>wWxXcCvVbBnN,?;.:/!¬ß                                    "))
    (quail-set-keyboard-layout "pc105-fr"))
#+end_src
* Programming


** Edition

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'prog-mode-hook
            (lambda ()
              (electric-layout-mode 1)
              (display-line-numbers-mode 1)
              (setq display-line-numbers-widen t)))
#+end_src

** Projects

#+begin_src emacs-lisp :tangle init.el
  (setq project-kill-buffers-display-buffer-list t
        project-vc-merge-submodules nil
        project-mode-line t)
#+end_src

** Highlight changes

#+begin_src emacs-lisp :tangle init.el
(add-hook 'prog-mode-hook
  (lambda ()
    (highlight-changes-mode)))

(setq highlight-changes-visibility-initial-state nil
      highlight-changes-invisibility-string "")
#+end_src

** On the fly code check

Flymake is used to check code on the fly.

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'flymake-mode-hook
            (lambda ()
              (keymap-local-set "C-c f d" 'flymake-show-buffer-diagnostics)
              (keymap-local-set "C-c f n" 'flymake-goto-next-error)
              (keymap-local-set "C-c f p" 'flymake-goto-prev-error)))
#+end_src

** Display of documentation

Prevent Eldoc mode from resizing echo area.

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load "eldoc"
  (setq eldoc-echo-area-use-multiline-p nil))
#+end_src

** Spell checking

When writing code source, I like to have comments, documentation and
string checked for right spelling. But one must check whether there is
a spell checker in path or not.

#+begin_src emacs-lisp :tangle init.el
  (require 'ispell)
  (setq has-spell-checker
        (not (eq (executable-find ispell-program-name) nil)))
  (when has-spell-checker
    (add-hook 'prog-mode-hook
              (lambda ()
                 (setq ispell-local-dictionary "english"
                       flyspell-persistent-highlight nil)))
    (add-hook 'rst-mode-hook
              (lambda ()
                (setq ispell-local-dictionary "english")
                (flyspell-mode))))
#+end_src

Configure =guess-language-mode= to be less intrusive in mode-line.

#+begin_src emacs-lisp :tangle init.el
  (when (locate-library "guess-language")
    (require 'guess-language)
    (setq guess-language-languages '(en fr)
  	guess-language-langcodes
  	'((en "en" "English" "üñçÔ∏èen" "English")
  	  (fr "francais" "French" "üñçÔ∏èfr" "French")))
    (add-hook 'text-mode-hook
  	    (lambda ()
  	      (guess-language-mode))))
#+end_src

*** TODO Disable spell menu when no spell program is found         :noexport:


** Long lines and buffer boundaries

#+begin_src emacs-lisp :tangle init.el
(add-hook 'prog-mode-hook
          (lambda ()
             (setq truncate-lines t
                   indicate-buffer-boundaries '((top . left) (bottom . right)))))
#+end_src

** Code navigation

Another way to browse tags found in the current buffer is to use the
index menu.

#+begin_src emacs-lisp :tangle init.el
(setq imenu-auto-rescan t
      imenu-max-items 35)
#+end_src

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'xref--xref-buffer-mode-hook
              (lambda ()
                (hl-line-mode)))

  (add-hook 'xref-after-update-hook
            #'(lambda ()
                (set (make-local-variable 'outline-regexp)
  					(if (eq xref-file-name-display 'abs)
  					    "/" "[^ 0-9]"))
                (setq outline-default-state 1
                      outline-default-rules '((match-regexp . "ChangeLog\\|test/manual/etags")))
                (outline-minor-mode)))
#+end_src

** Abbreviations

The file =~/.config/emacs/abbrev_defs= (or whatever the value of
=abbrev-file-name= is) defines abbreviations and their expansions. It
is read and saved silently.

#+begin_src emacs-lisp :tangle init.el
(let ((file abbrev-file-name))
  (when (file-readable-p file)
    (read-abbrev-file file t)))
(setq save-abbrevs 'silently)
#+end_src

While editing buffers in programming modes, insertion of an
abbreviation is automatically expanded and replaced by its expansion.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'prog-mode-hook
          (lambda ()
             (abbrev-mode)))
#+end_src

An other way to use abbreviations is to expand letters in the buffer
before point by looking for other words that start with those letters
in buffers. Expansion is performed dynamically. I am hooked to this.
To limit the number of dynamic expansions when editing files using
naming conventions mixing uppercase and lowercase letters, case is
significant while searching for expansions.

#+begin_src emacs-lisp :tangle init.el
(setq dabbrev-case-fold-search nil)
#+end_src

** Whitespaces

Key bindings to report and cleanup blank problems in all buffer or at
region.

#+begin_src emacs-lisp :tangle init.el
(require 'whitespace)
(define-prefix-command 'whitespace-prefix-map)
(keymap-global-set "C-c w" 'whitespace-prefix-map)
(keymap-set whitespace-prefix-map "t" 'whitespace-mode)
(keymap-set whitespace-prefix-map "c" 'whitespace-cleanup)
(keymap-set whitespace-prefix-map "r" 'whitespace-report)

(setq whitespace-style
      (quote (face empty spaces tabs newline space-mark trailing
                   tab-mark newline-mark lines-tail)))

(setq whitespace-display-mappings
      '((space-mark 32 [183] [46])
        (newline-mark 10 [182 10])
        (tab-mark 9 [8594 9] [92 9])))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'prog-mode-hook
  (lambda ()
    (setq show-trailing-whitespace t)))
#+end_src

** Glasses

Glasses help reading Camel case. I prefer parentheses to stick to the
preceding identifier and embedded capitals to be downcase.

#+begin_src emacs-lisp :tangle init.el
(require 'glasses)
(setq glasses-separate-parentheses-p nil
      glasses-uncapitalize-p t)
#+end_src

** Version control

I sometimes have directories both under [[http://subversion.apache.org/][Subversion]] and [[http://gitscm.org/][Git]]. As my
preferred version control backend is Git, the list of version control
backends must be reordered.

#+begin_src emacs-lisp :tangle init.el
(setq vc-handled-backends (cons 'Git (remove 'Git vc-handled-backends)))
#+end_src

Comparing revisions using Ediff is so pleasant that it deserves a key
binding, an alternative to the usefull =C-xvD= (binded to
=vc-root-diff=).

#+begin_src emacs-lisp :tangle init.el
(keymap-global-set "C-x v =" 'ediff-revision)
#+end_src

Spell checking is automatically enabled when editing log messages,
whether working with Git or Subversion from a shell, or using Emacs
version control interface.

Note that, when working with Git from a shell, the buffer opened to
edit a log message has =default-generic-mode= enabled because its
content match =generic-find-file-regexp= and
=generic-use-find-file-hook= default value is =t= .

#+begin_src emacs-lisp :tangle init.el
(when has-spell-checker
  (add-hook 'find-file-hook
            (lambda ()
               (when (string-match "^svn-commit" (buffer-name))
                 (setq ispell-local-dictionary "english")
                 (flyspell-mode))))

  (add-hook 'default-generic-mode-hook
            (lambda ()
               (when (equal (buffer-name) "COMMIT_EDITMSG")
                 (setq ispell-local-dictionary "english")
                 (flyspell-mode))))

  (add-hook 'log-edit-mode-hook
            (lambda ()
               (setq ispell-local-dictionary "english")
               (flyspell-mode))))
#+end_src

Shorten the display of the current branch name in the modeline.

#+begin_src emacs-lisp :tangle init.el
(load-library "vc-hooks")
(defun vc-git-mode-line-string (file)
  "Return a string for `vc-mode-line' to put in the mode line for FILE."
  (let* ((rev (vc-working-revision file 'Git))
         (disp-rev (or (vc-git--symbolic-ref file)
                       (substring rev 0 7)))
         (short-rev (if (<= (length disp-rev) 8)
                        disp-rev
                      (concat (substring disp-rev 0 7) "‚Ä¶")))
         (def-ml (vc-default-mode-line-string 'Git file))
         (help-echo (get-text-property 0 'help-echo def-ml))
         (face   (get-text-property 0 'face def-ml)))
    (propertize short-rev
                'face face
                'help-echo (concat help-echo "\nCurrent revision: " rev))))
#+end_src

When using Git in an shell buffer I prefer not to have a pager
filtering the output.

#+begin_src emacs-lisp :tangle init.el
(setenv "GIT_PAGER" "")
#+end_src

While merging changes, when the last conflic is resolved, don't leave
automaticaly =smerge-mode=; Otherwise I tend to use =smerge-mode= key
bindings after the mode has been deactivated.

#+begin_src emacs-lisp :tangle init.el
(require 'smerge-mode)
(with-eval-after-load "smerge-mode"
  (setq smerge-auto-leave nil))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'vc-diff-finish-functions
	  #'(lambda ()
	      (when outline-minor-mode
		(outline-apply-default-state))))
#+end_src

** Command interpreter

#+begin_src emacs-lisp :tangle init.el
(add-hook 'comint-mode-hook
          (lambda ()
             (setq indicate-empty-lines nil)
             (keymap-set comint-mode-map "C-c C-k" 'comint-kill-subjob)
             (setq comint-terminfo-terminal "ansi")
             (when (eq system-type 'windows-nt)
               (setq comint-process-echoes 'on))))
#+end_src

** Interactive shell

#+begin_src emacs-lisp :tangle init.el
(add-hook 'shell-mode-hook
          (lambda ()
             (setq shell-font-lock-keywords nil)
             (goto-address-mode)))
#+end_src


An abbreviation is defined for =&> /dev/null=.

#+begin_src emacs-lisp :tangle init.el
(define-abbrev-table 'shell-mode-abbrev-table '(("null" "&> /dev/null")))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'bash-ts-mode-hook
          (lambda ()
             (define-key bash-ts-mode-map "'" 'self-insert-command)))
#+end_src

Make comint process output to interpret OSC commands and configure
Bash prompt to emit such commands to make sure default directory is
updated in shell buffers.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'comint-output-filter-functions #'comint-osc-process-output)
#+end_src

#+begin_src sh :tangle init_bash.sh
set -x
osc7_cwd() {
    printf "\e]7;file://%s%s\e\\" "$HOSTNAME" "$PWD"
}
PROMPT_COMMAND=${PROMPT_COMMAND:+$PROMPT_COMMAND; }osc7_cwd
set +x
#+end_src

** Containers

#+begin_src emacs-lisp :tangle init.el
  (when (featurep 'dockerfile-ts-mode)
    (add-to-list 'auto-mode-alist '("Containerfile" . dockerfile-ts-mode)))
#+end_src

** Compilation                                                     :noexport:

Colorize compilation output.

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'compilation-filter-hook #'ansi-color-compilation-filter)

  (add-hook 'compilation-mode-hook
            (lambda ()
               (setq truncate-partial-width-windows nil)
               (keymap-set compilation-mode-map "c" 'compile)))
#+end_src

*** TODO Send a D-BUS notification at the end of compilation       :noexport:

Only if the compilation was lengthy.

** Make

#+begin_src emacs-lisp :tangle init.el
(add-hook 'makefile-gmake-mode-hook
          (lambda ()
             (setq tab-width 3)))
#+end_src

** Visual interface to diff and patch

Prefer to run the visual interface to diff in a single frame and split
that frame vertically or horizontally according to the frame geometry.

#+begin_src emacs-lisp :tangle init.el
(require 'ediff)
(add-hook 'ediff-mode-hook
          (lambda ()
             (setq ediff-window-setup-function 'ediff-setup-windows-plain)
             (when (< (* 2 (frame-height)) (frame-width))
               (setq ediff-split-window-function 'split-window-horizontally))))
#+end_src

White space visualization is useful when inspecting diffs. Also
prettification helps reading diffs; A command to easily toggle
prettification is defined.

#+begin_src emacs-lisp :tangle init.el
(require 'outline)
(add-hook 'diff-mode-hook
          (lambda ()
             (setq diff-font-lock-prettify t
                   outline-minor-mode-cycle t)
             (whitespace-mode)
             (outline-minor-mode)))


(defun diff-toggle-font-lock-prettify ()
  (interactive)
  (font-lock-unfontify-buffer)
  (setq diff-font-lock-prettify (not diff-font-lock-prettify))
  (font-lock-update))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'diff-mode-hook #'(lambda ()
			      (setq outline-default-state 1
				    outline-default-rules
				    '(subtree-is-long
				      subtree-has-long-lines
				      (match-regexp . "NEWS\\|test\\|package-lock\\.json\\|poetry\\.lock")))))
#+end_src

** Debugger, GDB

#+begin_src emacs-lisp :tangle init.el
  (require 'gdb-mi)
  (add-hook 'gdb-mode-hook
            (lambda ()
               (setq gdb-show-changed-values t
                     gdb-use-colon-colon-notation nil)))

  (require 'gud)
  (add-hook 'gud-mode-hook
            (lambda ()
               (setq gud-tooltip-mode nil
                     gud-gdb-command-name "gdb --silent --annotate=3")))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(defun alt-valgrind (file)
  (interactive "fEnter file: ")
  (shell-command (concat
                  "valgrind --leak-check=full  " file))
  (switch-to-buffer-other-window "*Shell Command Output*")
  (compilation-shell-minor-mode t))
#+end_src

** Support for C++

C++ developpers often name header files with the =.h= extension, like
C developpers. As I am more interested in C++, the default is to visit
such files in C++ mode. Whats more, candidate extensions for the
source file associated to a =.h= file are reordered to privilege C++
usual extensions rather than C ones (see =ff-find-other-file= binded
to =C-co= for a way to switch between implementation and declaration
on a file name basis).

#+begin_src emacs-lisp :tangle init.el
  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))

  (require 'find-file)
  (setcdr (assoc "\\.h\\'" cc-other-file-alist)
    (list (list ".cpp" ".cc" ".C" ".CC" ".cxx" ".c")))
#+end_src

Some abbreviation definitions for preprocessor directives are added.

#+begin_src emacs-lisp :tangle init.el
(define-skeleton cc-preprocessor-conditional-group
  "Insert a C preprocessor conditional group"
  "Group macro: " "#ifdef " str ?\n _ ?\n"#endif // " str ?\n)

(define-skeleton cc-preprocessor-not-conditional-group
  "Insert a C preprocessor conditional group"
  "Group macro: " "#ifndef " str ?\n _ ?\n"#endif // " str ?\n)

(define-skeleton cc-preprocessor-create-macro
  "Insert a C preprocessor macro creation"
  "Macro name: " "#define " str " " (skeleton-read "Macro expansion: ") _)

(define-skeleton cc-preprocessor-include-directive
  "Insert a C preprocessor include directive"
  "Header name: " "#include " str _)

(define-abbrev-table 'c++-ts-mode-abbrev-table
  '(("ppif" "" cc-preprocessor-conditional-group)
    ("ppnif" "" cc-preprocessor-not-conditional-group)
    ("ppd" "" cc-preprocessor-create-macro)
    ("ppi" "" cc-preprocessor-include-directive)))
#+end_src

#+begin_src emacs-lisp :tangle init.el
  (require 'c-ts-mode)
  (add-hook 'c++-ts-mode-hook
            (lambda ()
               (setq comment-style 'extra-line)
               (setq indent-tabs-mode nil)
               (keymap-set c++-ts-mode-map "C-c o" 'ff-find-other-file)
               (keymap-set c++-ts-mode-map "C-m" 'c-context-line-break)))
#+end_src

Update default text to insert into new files.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'auto-insert-alist
             '(("\\.\\([Hh]\\|hh\\|hpp\\)\\'" . "C / C++ header")
  t "#pragma once\n\n"))
#+end_src

** Qt

 #+begin_src emacs-lisp :tangle init.el
(add-to-list 'auto-mode-alist '("\\.qrc\\'" . xml-mode))
(add-to-list 'auto-mode-alist '("\\.qss\\'" . css-mode))
 #+end_src

** Support for Emacs Lisp

#+begin_src emacs-lisp :tangle init.el
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
             (set (make-local-variable 'comment-auto-fill-only-comments) t)
             (set (make-local-variable 'imenu-sort-function)
                  'imenu--sort-by-name)
             (keymap-set emacs-lisp-mode-map "C-c C-f"
               'emacs-lisp-byte-compile)))
#+end_src

To speedup Emacs Lisp execution, code can be compiled. The following
will compile a buffer on save if and only if an associated
byte-compiled file already exists.

#+begin_src emacs-lisp :tangle init.el
(defun byte-compile-current-buffer ()
  "Compile the current buffer if its major mode is
`emacs-lisp-mode' and an associated compiled file already
exists."
  (interactive)
  (when
      (and (eq major-mode 'emacs-lisp-mode)
           (file-exists-p (byte-compile-dest-file buffer-file-name)))
    (byte-compile-file buffer-file-name)))

(add-hook 'after-save-hook 'byte-compile-current-buffer)
#+end_src

** Support for Python

Some Linux distributions (e.g. Arch Linux) ship with both Python 2.x
and 3.x, thus the list of interpreters must be expanded accordingly
for file mode determination.

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load "python"
  (when (executable-find "python3")
    (setq python-shell-interpreter "python3")))
#+end_src

The style used for docstring is the one found in Django code
source. Outline minor mode put headings on classes and functions.

#+begin_src emacs-lisp :tangle init.el
(require 'python)
    (add-hook 'python-ts-mode-hook
              (lambda ()
                 (setq tab-width 4
                       gud-pdb-command-name (concat python-shell-interpreter " -m pdb ")
                       python-fill-docstring-style 'pep-257
    		   outline-regexp (python-rx (* space) defun))
  	       (outline-minor-mode)))
#+end_src

The Python documentation used to be distributed in Texinfo format. It
is not the case anymore since the documentation is handled by the
Sphinx framework. But it is still possible to generate Texinfo files
using Sphinx; Such files are easy to find on the web (if you don't
want to generate them by yourself...). The =info-look= setting for
=python-mode= must be updated to those new files.

#+begin_src emacs-lisp :tangle init.el
  (require 'info-look)
  (info-lookup-add-help
   :mode 'python-mode
   :regexp "[[:alnum:]_]+"
   :doc-spec '(("(python)Index" nil "")))
#+end_src

Usefull abbreviations.

#+begin_src emacs-lisp :tangle init.el
(define-abbrev-table 'python-mode-abbrev-table
  '(("pdb" "import pdb; pdb.set_trace()")))
#+end_src

Set the name of the Python template to insert at file creation.

#+begin_src emacs-lisp :tangle init.el
(let ((filename "python_template.py"))
  (when (file-exists-p (expand-file-name filename auto-insert-directory))
    (add-to-list 'auto-insert-alist
                 `(python-ts-mode . ,filename))))
#+end_src

** Support for Scheme

#+begin_src emacs-lisp :tangle init.el
(require 'scheme)
(add-hook 'scheme-mode-hook
          (lambda ()
             (setq scheme-program-name "umb-scheme")))
#+end_src

** Support for JavaScript

#+begin_src emacs-lisp :tangle init.el
(add-hook 'js-ts-mode-hook
          (lambda ()
             (setq indent-tabs-mode nil)
             (subword-mode)))
#+end_src

** Support for SQL

Hitting =;= in an interactive SQL buffer will send the current input
to the process.

#+begin_src emacs-lisp :tangle init.el
(require 'sql)
(setq sql-electric-stuff t)
#+end_src

** Support for PHP

#+begin_src emacs-lisp :tangle init.el
(when (locate-library "php-mode")
  (load-library "php-mode")
  (add-hook 'php-mode-hook 'flymake-mode))
#+end_SEC

* Text edition

#+begin_src emacs-lisp :tangle init.el
(add-hook 'text-mode-hook
          (lambda ()
             (goto-address-mode)
             (flyspell-mode)))
#+end_src

Insert double angle quotation marks in pairs.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'electric-pair-text-pairs
	     '(171 . 187))
#+end_src

** Support for SGML, HTML, CSS

It is difficult to avoid long lines when writing SGML files, thus
automatic line breaking is turned off.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'html-mode-hook
          (lambda ()
             (auto-fill-mode -1)
             (abbrev-mode)
             (when has-spell-checker
               (flyspell-mode))))
#+end_src

An abbreviation is defined for the Lorem Ipsum.

#+begin_src emacs-lisp :tangle init.el
(define-abbrev-table 'html-mode-abbrev-table
  '(("lorem"
     "<p>Lorem ipsum dolor sit amet, consectetur adipisicing
elit, sed do eiusmod tempor incididunt ut labore et dolore magna
aliqua. Ut enim ad minim veniam, quis nostrud exercitation
ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis
aute irure dolor in reprehenderit in voluptate velit esse cillum
dolore eu fugiat nulla pariatur. Excepteur sint occaecat
cupidatat non proident, sunt in culpa qui officia deserunt mollit
anim id est laborum.</p>")))
#+end_src

When available, load the package =flymake-csslint= to check code on the
fly.

#+begin_src emacs-lisp :tangle init.el
(when (locate-library "flymake-csslint")
  (require 'flymake-csslint)
  (add-hook 'css-mode-hook 'flymake-mode))
#+end_src

When available, load the package =rainbow-mode= to colorize strings
that represent colors.

#+begin_src emacs-lisp :tangle init.el
(when (locate-library "rainbow-mode")
  (require 'rainbow-mode)
  (add-hook 'css-mode-hook 'rainbow-mode))
#+end_src

** Support for MarkDown

#+begin_src emacs-lisp :tangle init.el
  (when (locate-library "markdown-mode")
    (require 'markdown-mode)
    (setq markdown-asymmetric-header t)
    (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode)))
#+end_src

** Support for TeX and LaTeX

When a file with =.tex= extension is opened, it is parsed to identify
if it is a TeX or a LaTeX file. The latter will be the default if the
parsing fails to identify whether it is a TeX or a LaTeX file.

#+begin_src emacs-lisp :tangle init.el
(setq tex-default-mode 'latex-mode)
#+end_src

#+begin_src emacs-lisp :tangle init.el
  (require 'tex-mode)
  (require 'reftex)
  (setq latex-run-command "latex -synctex=1 -interaction=nonstopmode")
  (add-hook 'latex-mode-hook
            (lambda ()
               (setq comment-style 'plain
                     comment-column 0
                     indent-tabs-mode nil
                     ispell-check-comments nil
                     tex-trailer "\\end{document}"
                     latex-block-default "theorem"
                     latex-block-names
                     '("theorem" "proposition" "definition" "lemma" "multline")
                     tex-open-quote "\\og "
                     tex-close-quote "\\fg")
               (define-skeleton alt-latex-math-env
                 "Create a matching pair of parenthesis."
                 nil 92 40 _ 92 41)
               (define-skeleton alt-latex-displaymath-env
                 "Create a matching pair of brackets."
                 nil 92 91 _ 92 93)
               (add-to-list 'tex-compile-commands
                            '("xdg-open %r.pdf &" "%r.pdf"))
               (reftex-mode t)
               (outline-minor-mode)
               (keymap-set latex-mode-map "M-<tab>" 'info-complete-symbol)
               (keymap-set latex-mode-map "C-c C-s" 'alt-latex-section)
               (keymap-set latex-mode-map "C-c m" 'alt-latex-math-env)
               (keymap-set latex-mode-map "C-c M" 'alt-latex-displaymath-env)))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'tex-shell-hook
          (lambda ()
             (add-to-list 'shell-font-lock-keywords
                    '("^\\(LaTeX Warning:\\|\\!\\)" . font-lock-warning-face))
             (keymap-set tex-shell-map "C-c C-p" 'comint-previous-prompt)))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(defun alt-auto-insert-latex ()
  "Ask the user for a LaTeX class and a language name, then
insert the corresponding template file in current buffer.

The relative name of the template file is LaTeX/CLASS-LANG.tex or
LaTeX/CLASS.tex if language is empty. This file is taken in the
directory `auto-insert-directory'.

If class is empty, the current buffer is expected to belong to a
multi-file document; The user is asked for the name of the main
document, then a skeleton with a reference to that name is
inserted."
  (let* ((class (completing-read "Document class: "
                                 '(("article" 1) ("report" 2) ("book" 3)
                                   ("letter" 4) ("slides" 5) ("exam" 6))))
         (lang (when (not (equal class ""))
                 (completing-read "Main language: "
                                  '(("french" 1) ("english" 2))))))
    (if (not (equal class ""))
        (let ((name (expand-file-name
                     (concat auto-insert-directory "LaTeX/" class
                             (when (not (equal lang ""))
                               (concat "-" lang)) ".tex"))))
          (if (file-readable-p name)
              (progn
                (insert "% Time-stamp: <" (current-time-string)
                        " " (user-login-name) ">\n% Author: "
                        (user-full-name) " <" (progn user-mail-address) ">\n\n")
                (insert-file-contents name))
            (message "No template file %s found" name)))
      (let ((name (read-file-name "Main file: " default-directory "")))
        (insert "% Time-stamp: <" (current-time-string)
                " " (user-login-name) ">\n% Author: " (user-full-name)
                " <" (progn user-mail-address) ">\n\n")
        (goto-char (point))
        (when (not (equal name ""))
          (save-excursion
            (insert "\n\n% Local Variables:\n% tex-main-file: \""
                    name "\"\n% End:\n")))))))

(add-to-list 'auto-insert-alist
             '(latex-mode . alt-auto-insert-latex))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'reftex-mode-hook
          (lambda ()
             (setq reftex-extra-bindings t
                   reftex-enable-partial-scans t
                   reftex-save-parse-info nil
                   reftex-use-multiple-selection-buffers t
                   reftex-label-alist
                   (setq reftex-label-alist
                         '(("theorem" ?h "thr:" "~\\ref{%s}" t
                            (regexp "th\\\(\\\(√©\\\|\'e\\\)or\\\(√®\\\|\`e\\\)mes?\\\|m\\\.\\\)") nil)
                           ("proposition" ?p "pro:" "~\\ref{%s}" t
                            (regexp "prop\\\(ositions?\\\|.\\\)") nil)
                           ("lemma" ?l "lem:" "~\\ref{%s}" t
                            (regexp "lem\\\(mes?\\\|.\\\)") nil)
                           ("equation" 101 "eq:" "~(\\ref{%s})" t
                            (regexp "\\\(l'\\\)?\\\(√©\\\|\'e\\\)quations?") nil)
                           ("example" ?x "exm:" "~\\ref{%s}" t
                            (regexp "exemp\\\(les?\\\|.\\\)")))))
             (defun reftex-page-reference ()
               "Make a LaTeX reference to a page number."
               (interactive)
               (let ((reftex-format-ref-function
                      `(lambda (label format)
                         (concat "~\\pageref{" label "}"))))
                 (reftex-reference)))
             (keymap-set reftex-mode-map "C-c ]" 'reftex-page-reference)
             (define-key-after reftex-mode-menu [pageref]
               '(menu-item "\\pageref" reftex-page-reference) '\\cite)))

(with-eval-after-load "reftex"
  (let ((dir (expand-file-name "~/Documents/Math√©matiques/Bibliographie")))
    (when (file-exists-p dir)
      (dolist (name (directory-files dir t ".*\.bib$"))
        (add-to-list 'reftex-default-bibliography name)))))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(defcustom latex-outline-max-level 4
  "Maximum level of outline headings used by imenu."
  :type 'integer
  :group 'tex)
#+end_src

#+begin_src emacs-lisp :tangle init.el
(defvar alt-latex-section-default "paragraph")

(define-skeleton alt-latex-section
  "Create a sectionning command \\SECTION{TITLE} at point."
  (let ((section (completing-read
                  (format "LaTeX section name [%s]: "
                          alt-latex-section-default)
                  latex-section-alist nil nil nil nil
                  alt-latex-section-default)))
    (setq alt-latex-section-default section))
  \n "\\" str ?\{ (skeleton-read "Title: ") ?\} \n \n)
#+end_src

** Support for reStructuredText

Auto fill mode may break the indentation.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'rst-mode-hook
          (lambda ()
            (auto-fill-mode -1)))

(let ((filename "template.rst"))
  (when (file-exists-p (expand-file-name filename auto-insert-directory))
    (add-to-list 'auto-insert-alist
                 `(rst-mode . ,filename))))
#+end_src
* File management

** Replace deletion by move to trash

#+begin_src emacs-lisp :tangle init.el
(setq delete-by-moving-to-trash t)
#+end_src

** File search

The function =xref-matches-in-files= is broken since handling of
binary files is done by parsing the output and depends on the local
for =grep= and =ugrep=. A fix consist to force those tools to ignore
matches found in binary files (=-I= option aka
=--binary-files=without-match=).

#+begin_src emacs-lisp :tangle init.el
(require 'xref)
(setq xref-search-program-alist
      '((grep . "xargs -0 grep <C> --null -snHE -I -e <R>")
	(ripgrep
	 . "xargs -0 rg <C> --null -nH --no-heading --no-messages -g '!*/' -e <R>")
	(ugrep . "xargs -0 ugrep <C> --null -ns -I -e <R>")))
#+end_src

When available, use `ripgrep` to search in files.

#+begin_src emacs-lisp :tangle init.el
(when (and (executable-find "rg")
           (assoc 'ripgrep xref-search-program-alist))
  (setq xref-search-program 'ripgrep))
#+end_src


** Enhancing file manager

#+begin_src emacs-lisp :tangle init.el
  (with-eval-after-load "dired"
    (require 'dired-x)
    (setq dired-x-hands-off-my-keys nil)
    (dired-x-bind-find-file)
    (setq dired-free-space 'first
          dired-listing-switches "-alh")
    (setq dired-isearch-filenames t
          dired-vc-rename-file t))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(require 'dired-x)
(setq dired-omit-files
  (concat dired-omit-files
     "\\|^__pycache__$"
     "\\|^\\.mypy_cache$"
     "\\|^\\."))
(add-to-list 'dired-omit-extensions ".egg-info")
(setq dired-omit-extensions (delete ".pdf" dired-omit-extensions))
(add-hook 'dired-mode-hook
          (lambda ()
             (setq dired-omit-size-limit nil
                   truncate-lines t)
             (dired-omit-mode 1)
             (dired-hide-details-mode 1)
             (set (make-local-variable 'transient-mark-mode) nil)
             (keymap-set dired-mode-map "w" 'dired-copy-filename-as-kill)))
#+end_src

* Code sources                                                     :noexport:

#+name: init.el_header
#+begin_src emacs-lisp
;;; -*- coding: utf-8; lexical-binding: t; -*-
;;; GNU Emacs Startup file

;;; WARNING This file was automatically generated: Do not edit
#+end_src

#+name: init.el_custom-file_loading
#+begin_src emacs-lisp :tangle init.el
(require 'cus-edit)
(setq custom-file (expand-file-name
                   (concat  "~/.config/emacs/" (system-name) "-custom.el")))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

#+name: init.el_system-name_loading
#+begin_src emacs-lisp :tangle init.el
(let ((file (locate-library (concat (system-name) ".el"))))
  (if file
      (load file t)
    (message "No machine specific initialization")))
#+end_src

# Local Variables:
# Mode: org
# indent-tabs-mode: nil
# End:
