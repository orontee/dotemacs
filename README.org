An Emacs configuration tour

#+startup: overview
#+language: en
#+drawers: PROPERTIES FEEDSTATUS
#+filetags: emacs
#+todo: TODO | DONE CANCELED
#+style: <link rel="stylesheet" type="text/css" href="css/clean.css" />
#+options: H:2 toc:nil todo:t email:t ^:nil

* Introduction

I am using [[http://www.gnu.org/software/emacs/][GNU Emacs]] since the late '90 on various environments, both
at home or at work. At the beginning, I used it to write LaTeX files:
I found that tool more or less randomly while sitting in front of one
of the X Window terminals of my university. Today, whatever I have to
do with a computer, it ends in an Emacs buffer... In my current use,
Emacs has become a kind of interface over the computer's operating
system (whatever it is: Arch Linux, Ubuntu, Windows XP, Vista and 10).
But suprisingly I feel like it has adapt to my needs rather than I
have limited myself to its features.

As an intensive Emacs user I had various needs related to Emacs
customization: Centralize all customization to be able to deploy
efficiently on multiple targets; Organize Emacs customization in the
order demanded by the flow of my needs rather than the one imposed by
the computer; Share Emacs customization; Gather links to external
tools; Log my contributions; Etc. Thus I have written an Org file
whose code blocks could be converted to the source file I use to
customize Emacs to my needs and, on the other hand, is the source of
the documentation you are reading.

*Downloads*

You can download this [[file:README.org][Org file]] and build the corresponding =init.el= using
=org-babel-tangle=, or simply clone this repository and use =GNU Make=
to build that file.

*References*

Most of the following code snippets I have written myself. Some were
copied from the [[https://lists.gnu.org/mailman/listinfo/help-gnu-emacs][gnu.emacs.help newsgroup]] or the [[http://www.emacswiki.org/][Emacs wiki]].

* General use
** Header                                                          :noexport:

#+begin_src emacs-lisp :tangle init.el :noweb tangle
<<init.el_header>>
#+end_src

** Checking emacs version

Despite a common misconception, GNU Emacs is actively maintained and
last versions were greatly improved. A recent version is required. It
can be downloaded from http://ftp.gnu.org/pub/gnu/emacs/.

#+begin_src emacs-lisp :tangle init.el
(when (or (< emacs-major-version 24)
          (and (= emacs-major-version 24)
               (< emacs-minor-version 3)))
  (error "Wrong Emacs version, update or remove the configuration
  file"))
#+end_src

** Extending Emacs, packages repositories, etc

The easiest way to extend Emacs features is to use =list-package= and
install packages from remote repositories. But =package.el= is rather
new and not all libraries are available in the form of packages. When
a library must be installed by hand, a good practice is to always put
it in the directory =~/.config/emacs/lisp=. The load path is extended
accordingly.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'load-path (expand-file-name "~/.config/emacs/lisp/"))
#+end_src

The default is to fetch packages from the GNU Emacs packages
repository. There are usefull packages in other places like [[http://tromey.com/elpa/][ELPA]] and
[[http://marmalade-repo.org/][Marmalade]].

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load "package"
  (add-to-list 'package-archives '("melpa". "https://melpa.org/packages/")))
#+end_src

At the time of writing, I have activated the following packages:

#+begin_src emacs-lisp :exports results :results value raw
(let ((descriptions "|Package|Description|\n|---|\n"))
  (dolist (package package-alist descriptions)
    (let ((name (car package))
          (desc (package-desc-summary (cadr package))))
    (setq descriptions
          (concat descriptions (format "|%s|%s|\n" name desc))))))
#+end_src

#+RESULTS:
| Package          | Description                                               |
|------------------+-----------------------------------------------------------|
| corfu            | COmpletion in Region FUnction                             |
| which-key        | Display available keybindings in popup                    |
| spacious-padding | Increase the padding/spacing of frames and windows        |
| rfc-mode         | RFC document browser and viewer                           |
| restclient       | An interactive HTTP client for Emacs                      |
| nginx-mode       | major mode for editing nginx config files                 |
| modus-themes     | Elegant, highly legible and customizable themes           |
| meson-mode       | Major mode for the Meson build system files               |
| markdown-mode    | Major mode for Markdown-formatted text                    |
| guess-language   | Robust automatic language detection                       |
| gpx              | Major mode for GPX files                                  |
| gptel            | Interact with ChatGPT or other LLMs                       |
| git-link         | Get the GitHub/Bitbucket/GitLab URL for a buffer location |
| edit-indirect    | Edit regions in separate buffers                          |
| diminish         | Diminished modes are minor modes with no modeline display |
| devhelp          | Browse documentation in Devhelp format                    |
| darkroom         | Remove visual distractions and focus on writing           |
| consult          | Consulting completing-read                                |
| compat           | Emacs Lisp Compatibility Library                          |
| cmake-mode       | major-mode for editing CMake sources                      |
| breadcrumb       | project and imenu-based breadcrumb paths                  |
| Python-doc       | Info documentation for Python                             |
| CMake-doc        | Info documentation for CMake                              |

All settings written using the customize library go to a dedicated
file that is loaded when the loading of the [[file:.init.el][configuration file]] ends.

#+begin_src emacs-lisp :noweb yes
<<init.el_custom-file_loading>>
#+end_src

When the custom settings are loaded, a machine specific file is
loaded. The file name comes from the host name of the machine Emacs is
running on.

#+begin_src emacs-lisp :noweb yes
<<init.el_system-name_loading>>
#+end_src

** Widening the screen

You feel like the computer screen is too narrow, don't you? So menu
bars, scroll bars and tool bars must be disabled. Whats more,
disabling this eyecandy may improve responsiveness when Emacs run on a
remote computer forwarding X11. Note that the content of the menu bar
is still available by pressing =f10= or the contextual menu bind to
=C-mouse-1=.

#+begin_src emacs-lisp :tangle init.el
(when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(when (fboundp 'horizontal-scroll-bar-mode) (horizontal-scroll-bar-mode -1))
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+end_src

Don't know how to scroll buffers now that the scrollbar is gone? Read
the descriptions of the following key bindings: =M-v=, =C-v=, =M-C-v=,
=S-M-C-v=, =C-l=, =C-M-l=, =<prior>=, =<next>=, etc. Why should we add
scrollbars? By the way, the mode line indicates the percentage of the
buffer above the top of the window. And the column number is available
from the output of =C-x== (bind to =what-cursor-position=).

Another way to widen the screen is to truncate long lines and change
the text scale in secondary buffers. Restoring or changing the text
scale can be done interactively with =C-xC-0=, =C-xC-+= and =C-xC-=.

#+begin_src emacs-lisp :tangle init.el
  (when (require 'face-remap)
    (dolist (hook '(apropos-mode-hook
                    gdb-breakpoints-mode-hook
                    gdb-frames-mode-hook
                    gdb-inferior-io-mode-hook
                    gdb-locals-mode-hook
                    vc-dir-mode-hook
                    xref--xref-buffer-mode-hook
                    flymake-diagnostics-buffer-mode-hook
                    gdb-mode-hook
                    grep-mode-hook
                    occur-mode-hook
                    speedbar-mode-hook))
      (add-hook hook
                (lambda ()
                  (setq truncate-lines t)
                  (when (not text-scale-mode)
                    (text-scale-set -1))))))
  (add-hook 'compilation-mode-hook
    (lambda ()
      (when (not text-scale-mode)
        (text-scale-set -1))))
#+end_src

I also like to have a clear mode line. Most of the time the minor
modes indicators don't bring much information and I prefer to remove
them:
#+begin_src emacs-lisp :tangle init.el
(setq flyspell-mode-line-string nil)
(when (locate-library "which-key")
  (load-library "which-key")
  (setq which-key-lighter ""))
#+end_src

Diminish mode-line display of minor modes.

#+begin_src emacs-lisp :tangle init.el
(when (locate-library "diminish")
  (require 'diminish)
  (diminish 'completion-preview-mode)
  (diminish 'eldoc-mode)
  (diminish 'abbrev-mode))
#+end_src

** Bookmarks

Lighter bookmark menu: Filenames are hidden and more horizontal space
is dedicated to bookmark names.

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load "bookmark"
  (setq bookmark-bmenu-file-column 60
        bookmark-bmenu-toggle-filenames nil))
#+end_src

** Generic modes

From the docstring: Generic modes provide basic comment and font-lock
functionality for "generic" files. (Files which are too small to
warrant their own mode, but have comment characters, keywords, and the
like.)

The file =generic-x.el= contains a collection of generic modes. The
default is to enable generic modes according to the host operating
system; I prefer to always define MS Windows generic modes for I
sometime have to work on script files for the MS Windows command
line...

#+begin_src emacs-lisp :tangle init.el
  (load "generic-x")
  (setq generic-extras-enable-list
        (append generic-default-modes
                generic-mswindows-modes
                generic-unix-modes))
  (load "generic-x")
#+end_src

The =systemd= configuration files are Conf files.

#+begin_src emacs-lisp :tangle init.el
(when (eq system-type 'gnu/linux)
  (add-to-list 'auto-mode-alist
               '("\\.service\\'" . conf-mode)))
#+end_src

Bind =rc-generic-mode= to Visual Studio Resource files.

#+begin_src emacs-lisp :tangle init.el
  (add-to-list 'auto-mode-alist
               '("\\.rc2\\'" . rc-generic-mode))
(add-to-list 'auto-mode-alist
             '("\\git-rebase-todo\\'" . default-generic-mode))
#+end_src

** Auto insertion at file creation

Auto insertion of templates at file creation is enabled and the
location where templates are searched is defined.

#+begin_src emacs-lisp :tangle init.el
(auto-insert-mode)
(let ((file (expand-file-name "~/Modèles")))
  (when (file-exists-p file)
    (setq auto-insert-directory file)))
#+end_src

** Revert buffers on file changes

Reverts any buffer associated with a file when the file changes on
disk. For files with =.log= extension, the tail is constantly
followed.

#+begin_src emacs-lisp :tangle init.el
(global-auto-revert-mode)

(add-hook 'find-file-hook
          (lambda()
             (when (and (buffer-file-name)
                        (equal (file-name-extension (buffer-file-name)) "log"))
               (auto-revert-tail-mode))))
#+end_src

** Handle long lines

#+begin_src emacs-lisp :tangle init.el
(global-so-long-mode 1)
#+end_src

** Moving between windows and selecting buffers

Usually the frame is split at most twice. I find =C-xo= sufficient to
change the selected window along the three candidates.\

To select a buffer I often use =C-xb= and completion. When my brain
can't remember the buffer name, I use the default buffer menu
(accessible from =C-xC-b= and =C-uC-xC-b=) or =icomplete-mode=. That's
all. No =ido=, =icycle=, etc.

#+begin_src emacs-lisp :tangle init.el
(icomplete-mode 1)
(setq icomplete-in-buffer t)
(setq confirm-nonexistent-file-or-buffer t)
#+end_src

Completion of bookmarks names uses substring style.
#+begin_src emacs-lisp :tangle init.el
(add-to-list 'completion-category-overrides '(bookmark (styles substring)))
#+end_src

** Cycling spacing

#+begin_src emacs-lisp :tangle init.el
(global-set-key (kbd "M-SPC") 'cycle-spacing)
#+end_src

** Empty scratch buffer

#+begin_src emacs-lisp :tangle init.el
(setq initial-scratch-message nil)
#+end_src

** Diary and calendar customization

A diary file is automatically created.

#+begin_src emacs-lisp :tangle init.el
(let ((file (expand-file-name "~/.config/emacs/diary")))
  (when (not (file-exists-p file))
    (write-region "" nil file))
  (setq diary-file file))
#+end_src

The calendar is configured to match the french standards.

#+begin_src emacs-lisp :tangle init.el
(setq european-calendar-style t
      calendar-time-display-form
      '(24-hours ":" minutes
                 (if time-zone " (") time-zone (if time-zone ")"))
      calendar-week-start-day 1
      calendar-intermonth-text
      '(propertize
        (format "%2d"
                (car
                 (calendar-iso-from-absolute
                  (calendar-absolute-from-gregorian (list month day year)))))
        'font-lock-face 'font-lock-function-name-face))

(setq view-diary-entries-initially t
      number-of-diary-entries [0 2 2 2 2 4 1]
      mark-diary-entries-in-calendar t
      view-calendar-holidays-initially nil
      mark-holidays-in-calendar t
      general-holidays nil
      hebrew-holidays nil
      all-christian-calendar-holidays t
      islamic-holidays nil
      oriental-holidays nil)

(add-hook 'today-visible-calendar-hook 'calendar-mark-today)

(add-hook 'diary-display-hook 'fancy-diary-display)
#+end_src

French holidays are be added to the calendar. Note that Christian
holidays are already present into the calendar since we have set
=all-christian-calendar-holidays= to =t=.

#+begin_src emacs-lisp :tangle init.el
(setq french-holiday
      '((holiday-fixed 1 1 "Jour de l'an")
        (holiday-fixed 5 1 "Fête du travail")
        (holiday-fixed 5 8 "Victoire 1945")
        (holiday-fixed 7 14 "Fête nationale")
        (holiday-fixed 11 1 "Toussaint")
        (holiday-fixed 11 11 "Armistice 1918")))

(setq holiday-other-holidays
      (append french-holiday holiday-other-holidays))
#+end_src

** Electric modes

Enable pairing to insert pairs of matching characters.

#+begin_src emacs-lisp :tangle init.el
(electric-pair-mode)
#+end_src

** Save place

Automatically save place of cursor in each file.

#+begin_src emacs-lisp :tangle init.el
(save-place-mode 1)
#+end_src

** Archives display

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load "tar-mode"
  (setq tar-mode-show-date t))
#+end_src

** Time and date

When working in a console, it is sometime usefull to get the time:
=M-! date= is ok for this. To display the time in the modeline there
is =display-time-mode=.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'display-time-mode-hook
          (lambda ()
             (setq display-time-day-and-date nil
                   display-time-24hr-format t
                   display-time-use-mail-icon nil
                   display-time-format "%A,%e %B %Y %R")))
#+end_src

** Syntax highlighting

#+begin_src emacs-lisp :tangle init.el
(add-hook 'font-lock-mode-hook
          (lambda ()
             (show-paren-mode)))

(add-hook 'show-paren-mode-hook
          (lambda ()
             (setq show-paren-style 'parenthesis)))
#+end_src

** Final new line

All files will have a newline at their end.

#+begin_src emacs-lisp :tangle init.el
(setq require-final-newline t)
#+end_src

** Language environment

The preferred input method is set according to the current language
environment. I prefer to use prefix modifiers (use =C-hI= to get a
description of any input method). Note that the default language
environment is set during startup, before the user init file is
loaded; It explains the explicit call to our
=choose-language-input-method=.

#+begin_src emacs-lisp :tangle init.el
(defun choose-language-input-method ()
  "Set default input method according to current language
environment."
  (let* ((language-name current-language-environment)
         (method (cond
                  ((string= language-name "French")
                   'french-prefix)
                  ((or (string= language-name "Latin-1")
                       (string= language-name "UTF-8"))
                   'latin-1-prefix)
                  (t nil))))
    (setq default-input-method method)))

(add-hook 'set-language-environment-hook
          (lambda ()
            (choose-language-input-method)))

(choose-language-input-method)
#+end_src

But there are other input methods I use: For example the TeX method.
Key sequences are defined to easily set the input methods I need.

#+begin_src emacs-lisp :tangle init.el
(dolist (elt '(("1" . "latin-1-prefix")
               ("9" . "latin-9-prefix")
               ("u" . "TeX")))
  (define-key mule-keymap (car elt)
    `(lambda ()
       (interactive)
       (set-input-method ,(cdr elt)))))
#+end_src

** Display settings

Group buffers by their major modes when using the contextual menu to
select a buffer.

#+begin_src emacs-lisp :tangle init.el
(context-menu-mode)
(with-eval-after-load "mouse"
  (setq mouse-buffer-menu-mode-mult 2)
  (add-to-list 'mouse-buffer-menu-mode-groups '("Dired" . "Dired"))
  (add-to-list 'mouse-buffer-menu-mode-groups '("tex" . "TeX/LaTeX")))
#+end_src

Highlight the current line and indicates buffer boundaries in table
based buffers and alike ones.

#+begin_src emacs-lisp :tangle init.el
  (dolist (hook '(tabulated-list-mode-hook
                  bookmark-bmenu-mode-hook
                  log-view-mode-hook))
    (add-hook hook
              (lambda ()
                (hl-line-mode)
                (setq indicate-buffer-boundaries
                      '((top . left) (bottom . right))))))
#+end_src

Silent bell.

#+begin_src emacs-lisp :tangle init.el
(setq visible-bell t)
#+end_src

Use pixel precision scrolling.

#+begin_src emacs-lisp :tangle init.el
(pixel-scroll-precision-mode)
(setq pixel-scroll-precision-large-scroll-height 40.0)
#+end_src

** Tab bar

I like tabs but want them to use the same keybindings as GTK-based
applications. Also I want new tabs to display bookmarks.

#+begin_src emacs-lisp :tangle init.el
(require 'bookmark)
(defun get-or-build-bookmark-buffer ()
  (cond
   ((get-buffer bookmark-bmenu-buffer))
   (t (save-excursion
        (save-window-excursion
          (bookmark-bmenu-list)
          (get-buffer bookmark-bmenu-buffer))))))

(when (featurep 'tab-bar)
  (setq tab-bar-close-button-show t
        tab-bar-close-last-tab-choice 'delete-frame
        tab-bar-close-tab-select 'left
        tab-bar-new-tab-choice 'get-or-build-bookmark-buffer
        tab-bar-select-tab-modifiers '(meta))
  (define-key tab-prefix-map "1" nil)
  (global-set-key [C-next] 'tab-bar-switch-to-next-tab)
  (global-set-key [C-prior] 'tab-bar-switch-to-prev-tab)
  (global-set-key [C-S-next] (lambda () (interactive) (tab-bar-move-tab 1)))
  (global-set-key [C-S-prior] (lambda () (interactive) (tab-bar-move-tab -1))))
#+end_src

** Frame customization definitions

#+begin_src emacs-lisp
(setq default-frame-alist
      '((menu-bar-lines . nil)
        (tool-bar-lines . nil)
        (vertical-scroll-bars . nil)
        (horizontal-scroll-bars . nil)
        (font . "Inconsolata-10")
        (cursor-color . "red3")))
#+end_src

For X Window frames, it is better to customize the [[file:~/.Xresources][resources file]]:

#+begin_src x-resource-generic-mode
! Emacs frame customization
Emacs.menuBar: off
Emacs.toolBar: off
Emacs.verticalScrollBars: off
Emacs.font: Inconsolata-10
Emacs
#+end_src

*** TODO Add the equivalent for MS Windows

** Documentation, help

#+begin_src emacs-lisp :tangle init.el
(add-hook 'Info-mode-hook
          (lambda ()
             (setq truncate-lines t)))

(let ((path (expand-file-name "~/.local/share/info/")))
  (when (file-accessible-directory-p path)
    (add-to-list 'Info-additional-directory-list path)))
#+end_src

#+begin_src emacs-lisp :tangle init.el
  (when (locate-library "which-key")
    (load-library "which-key")
    (which-key-mode))
#+end_src

** Tab bar

#+begin_src emacs-lisp :tangle init.el
  (setq tab-bar-close-button-show 'selected
        tab-bar-format
  	'(tab-bar-format-menu-bar tab-bar-format-history tab-bar-format-tabs
  				  tab-bar-separator)
  	tab-bar-show t)
#+end_src

** Server, daemon

A server is started if and only if the running process is not a daemon
and there is not already a server started. In that way the Emacs
client will always find someone to talk to.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'server-switch-hook 'raise-frame)

(load-library "server")
(when (not (or (server-running-p) (daemonp)))
  (server-start))
#+end_src

To have =emacsclient= called by =sudoedit=, =git= and other programs
when they are tell to edit a file, [[file:~/.bashrc][Bash configuration file]] contains
the following snippet:

#+begin_src shell-script-mode
builtin type -p emacsclient &>/dev/null
[ -n $@ ] && export EDITOR=emacsclient
#+end_src

I also define an [[file:~/.bash_aliases][Bash alias]] to launch Emacs in terminals:

#+begin_src shell-script-mode
function is_command { type "$1" &> /dev/null; }
is_command emacs      && alias     em='emacsclient -t'
#+end_src

*** TODO Windows equivalent


** Minibuffer history

#+begin_src emacs-lisp :tangle init.el
(savehist-mode)
#+end_src

** MinGW

In case there MinGW is installed, the list of directories where to
search programs, the =PATH= environment variable and the list of
directories where to search documentation files are extended.

Similar tweaks are done for Ghostscript, GNU Aspell, Visual Studio.

#+begin_src emacs-lisp :tangle init.el
  (when (eq system-type 'windows-nt)
    (setq find-ls-option '("-exec ls -ld {} +" . "-ld"))
    (let ((mingw-root "C:\\GNU\\MinGW"))
      (when (file-exists-p mingw-root)
        ;; MinGW
        (setenv "PATH" (concat mingw-root "\\bin" ";" (getenv "PATH")))
        (add-to-list 'exec-path (expand-file-name "bin" mingw-root))
        (add-to-list 'Info-directory-list
                     (expand-file-name "share/info" mingw-root))
        ;; MSYS
        (let ((msys-root (concat mingw-root "\\msys\\1.0")))
          (when (file-exists-p msys-root)
            (setenv "PATH" (concat msys-root "\\bin" ";" (getenv "PATH")))
            (add-to-list 'exec-path (expand-file-name "bin" msys-root))
            (setenv "PATH" (concat msys-root "\\local\\bin"  ";" (getenv "PATH")))
            (add-to-list 'exec-path (expand-file-name "local/bin" msys-root))
            (add-to-list 'Info-directory-list
                         (expand-file-name "share/info" msys-root))
            (require 'grep)
            (grep-apply-setting 'grep-command
                                (expand-file-name "bin/grep.exe" msys-root))
            (grep-apply-setting 'grep-find-command
                                (expand-file-name "bin/find.exe" msys-root))))))
    (let ((gs-root "C:\\Program Files (x86)\\gs\\gs9.14"))
      (when (file-exists-p gs-root)
        (setenv "PATH" (concat gs-root "\\bin" ";" (getenv "PATH")))
        (setenv "PATH" (concat gs-root "\\lib" ";" (getenv "PATH")))
        (add-to-list 'exec-path (expand-file-name "bin" gs-root))
        (add-to-list 'exec-path (expand-file-name "lib" gs-root))
        (require 'doc-view)
        (setq doc-view-ghostscript-program "gswin32c.exe")))
    (let ((aspell-root "C:\\GNU\\aspell"))
      (when (file-exists-p aspell-root)
        (setenv "PATH" (concat aspell-root "\\bin" ";" (getenv "PATH")))
        (add-to-list 'exec-path (expand-file-name "bin" aspell-root))))
    (let ((visual-studio-root "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0")
          (dotnet-framework-root "C:\\Windows\\Microsoft.NET\\Framework\v4.0.30319"))
      (when (file-exists-p visual-studio-root)
        (setenv "PATH" (concat visual-studio-root "\\Common7\\IDE" ";" (getenv "PATH")))
        (add-to-list 'exec-path (expand-file-name "Common7/IDE" visual-studio-root))
        (add-to-list 'auto-mode-alist
               `(,(expand-file-name "VC/include" visual-studio-root) . c++-mode)))
      (when (file-exists-p dotnet-framework-root)
        (setenv "PATH" (concat dotnet-framework-root ";" (getenv "PATH"))))))
#+end_src


** Theme

Apply Modus theme for accessible readability.

#+begin_src emacs-lisp :tangle init.el
  (require 'modus-themes)

  (defun personal-modus-themes-custom-faces ()
    (modus-themes-with-colors
      (custom-set-faces
       ;; variable pitch face in info headings
       `(info-title-1 ((,c :inherit info-title-2 :height 1.2 :foreground ,fg-heading-1)))
       `(info-title-2 ((,c :inherit info-title-3 :height 1.2 :foreground ,fg-heading-2)))
       `(info-title-3 ((,c :inherit info-title-4 :height 1.2 :foreground ,fg-heading-3)))
       `(info-title-4 ((,c :inherit (bold variable-pitch) :height 1.0 :foreground ,fg-heading-4)))
       ;; variable pitch face in markdown headings
       `(markdown-header-face-1 ((,c :inherit markdown-header-face-2 :height 1.2 :foreground ,fg-heading-1)))
       `(markdown-header-face-2 ((,c :inherit markdown-header-face-3 :height 1.2 :foreground ,fg-heading-2)))
       `(markdown-header-face-3 ((,c :inherit markdown-header-face-4 :height 1.2 :foreground ,fg-heading-3)))
       `(markdown-header-face-4 ((,c :inherit (bold variable-pitch) :height 1.0 :foreground ,fg-heading-4)))
       ;; smaller line numbers
       `(line-number  ((,c :inherit default :height 0.8 :foreground ,fg-dim))))))

  (setq modus-themes-variable-pitch-ui nil
        modus-themes-to-toggle '(modus-operandi-tinted modus-vivendi-tinted))

  (add-hook 'modus-themes-after-load-theme-hook #'personal-modus-themes-custom-faces)

  (load-theme 'modus-operandi-tinted :no-confirm)
  (personal-modus-themes-custom-faces)
#+end_src

Spacious padding make the UI even more readable.

#+begin_src emacs-lisp :tangle init.el
  (when (locate-library "spacious-padding")
    (require 'spacious-padding)

    (defun my-custom-faces-after-spacious-padding (&optional frame)
      "Set face attributes after `spacious-padding-mode'.
  Add this to the `spacious-padding-mode-hook'."
      ;; Add more `set-face-attribute' calls here
      (set-face-attribute 'line-number (or frame (window-frame)) :height 0.7))

    (add-hook 'spacious-padding-mode-hook #'my-custom-faces-after-spacious-padding)
    (add-hook 'after-make-frame-functions #'my-custom-faces-after-spacious-padding)

    (spacious-padding-mode))
#+end_src

** Persistence

Save Emacs state from one session to another.

#+begin_src emacs-lisp :tangle init.el
  (setq desktop-restore-frames nil
 	desktop-restore-eager nil
 	desktop-lazy-verbose t)

  (desktop-save-mode)
#+end_src

** Various

Tired of typing =yes= and =no=? Prefer =y= and =n=!

#+begin_src emacs-lisp :tangle init.el
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

These are some core features disabled for newbies.

#+begin_src emacs-lisp :tangle init.el
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'scroll-left 'disabled nil)
#+end_src

Pacman package build files are shell scripts.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'auto-mode-alist '("PKGBUILD\\'" . sh-mode))
#+end_src

Extend executable path.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'exec-path (expand-file-name "~/.local/bin"))
#+end_src

Display current working directory in `shell-command` and
`async-shell-command`.
#+begin_src emacs-lisp :tangle init.el
(setq shell-command-prompt-show-cwd t)
#+end_src

Use single character to indicate string truncation.

#+begin_src emacs-lisp :tangle init.el
(setq truncate-string-ellipsis "…")
#+end_src

#+begin_src emacs-lisp :tangle init.el
  (setq major-mode-remap-alist
        '((bash-mode . bash-ts-mode)
          (c++-mode . c++-ts-mode)
          (c-mode . c-ts-mode)
          (css-mode . css-ts-mode)
          (js-mode . js-ts-mode)
  	(javascript-mode . js-ts-mode)
          (json-mode . json-ts-mode)
          (python-mode . python-ts-mode)
          (typescript-mode . typescript-ts-mode)
          (yaml-mode . yaml-ts-mode)))
#+end_src

* Programming


** Edition

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'prog-mode-hook
            (lambda ()
              (electric-layout-mode 1)
              (display-line-numbers-mode 1)
              (setq display-line-numbers-widen t)))
#+end_src

** Projects

#+begin_src emacs-lisp :tangle init.el
(setq project-kill-buffers-display-buffer-list t
      project-vc-merge-submodules nil)
#+end_src

** Highlight changes

#+begin_src emacs-lisp :tangle init.el
(add-hook 'prog-mode-hook
  (lambda ()
    (highlight-changes-mode)))

(setq highlight-changes-visibility-initial-state nil
      highlight-changes-invisibility-string "")
#+end_src

** On the fly code check

Flymake is used to check code on the fly.

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'flymake-mode-hook
            (lambda ()
              (local-set-key "\C-cfd" 'flymake-show-buffer-diagnostics)
              (local-set-key "\C-cfn" 'flymake-goto-next-error)
              (local-set-key "\C-cfp" 'flymake-goto-prev-error)))
#+end_src

** Display of documentation

Prevent Eldoc mode from resizing echo area.

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load "eldoc"
  (setq eldoc-echo-area-use-multiline-p nil))
#+end_src

** Spell checking

When writing code source, I like to have comments, documentation and
string checked for right spelling. But one must check whether there is
a spell checker in path or not.

#+begin_src emacs-lisp :tangle init.el
  (require 'ispell)
  (setq has-spell-checker
        (not (eq (executable-find ispell-program-name) nil)))
  (when has-spell-checker
    (add-hook 'prog-mode-hook
              (lambda ()
                 (setq ispell-local-dictionary "english"
                       flyspell-persistent-highlight nil)))
    (add-hook 'rst-mode-hook
              (lambda ()
                (setq ispell-local-dictionary "english")
                (flyspell-mode))))
#+end_src

Configure =guess-language-mode= to be less intrusive in mode-line.

#+begin_src emacs-lisp :tangle init.el
  (when (locate-library "guess-language")
    (require 'guess-language)
    (setq guess-language-languages '(en fr)
  	guess-language-langcodes
  	'((en "en" "English" "🖍️en" "English")
  	  (fr "francais" "French" "🖍️fr" "French")))
    (add-hook 'text-mode-hook
  	    (lambda ()
  	      (guess-language-mode))))
#+end_src

*** TODO Disable spell menu when no spell program is found         :noexport:


** Long lines and buffer boundaries

#+begin_src emacs-lisp :tangle init.el
(add-hook 'prog-mode-hook
          (lambda ()
             (setq truncate-lines t
                   indicate-buffer-boundaries '((top . left) (bottom . right)))))
#+end_src

** Code navigation

Another way to browse tags found in the current buffer is to use the
index menu.

#+begin_src emacs-lisp :tangle init.el
(setq imenu-auto-rescan t
      imenu-max-items 35)
#+end_src

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'xref--xref-buffer-mode-hook
              (lambda ()
                (hl-line-mode)))

  (add-hook 'xref-after-update-hook
            #'(lambda ()
                (setq outline-regexp (if (eq xref-file-name-display 'abs)
                                         "/" "[^ 0-9]")
                      outline-default-state 1
                      outline-default-rules '((match-regexp . "ChangeLog\\|test/manual/etags")))
                (outline-minor-mode)))
#+end_src

** Completion

When reading file or buffer names the case will be ignored.

#+begin_src emacs-lisp :tangle init.el
(setq read-file-name-completion-ignore-case t
      read-buffer-completion-ignore-case t)
#+end_src

Displays a completion suggestion for the symbol at point in an
overlay after point.

#+begin_src emacs-lisp :tangle init.el
(global-completion-preview-mode t)
#+end_src

Make completion at point popup a small window with completion
candidates in programming modes.

#+begin_src emacs-lisp :tangle init.el
  (when (locate-library "corfu")
    (load-library "corfu")
    (add-hook 'prog-mode-hook (lambda ()
  			      (corfu-mode))))
#+end_src

** Abbreviations

The file =~/.config/emacs/abbrev_defs= (or whatever the value of
=abbrev-file-name= is) defines abbreviations and their expansions. It
is read and saved silently.

#+begin_src emacs-lisp :tangle init.el
(let ((file abbrev-file-name))
  (when (file-readable-p file)
    (read-abbrev-file file t)))
(setq save-abbrevs 'silently)
#+end_src

While editing buffers in programming modes, insertion of an
abbreviation is automatically expanded and replaced by its expansion.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'prog-mode-hook
          (lambda ()
             (abbrev-mode)))
#+end_src

An other way to use abbreviations is to expand letters in the buffer
before point by looking for other words that start with those letters
in buffers. Expansion is performed dynamically. I am hooked to this.
To limit the number of dynamic expansions when editing files using
naming conventions mixing uppercase and lowercase letters, case is
significant while searching for expansions.

#+begin_src emacs-lisp :tangle init.el
(setq dabbrev-case-fold-search nil)
#+end_src

** Whitespaces

Key bindings to report and cleanup blank problems in all buffer or at
region.

#+begin_src emacs-lisp :tangle init.el
(define-prefix-command 'ctl-cw-map)
(global-set-key "\C-cw" 'ctl-cw-map)
(define-key ctl-cw-map "t" 'whitespace-mode)
(define-key ctl-cw-map "c" 'whitespace-cleanup)
(define-key ctl-cw-map "r" 'whitespace-report)

(setq whitespace-style
      (quote (face empty spaces tabs newline space-mark trailing
                   tab-mark newline-mark lines-tail)))

(setq whitespace-display-mappings
      '((space-mark 32 [183] [46])
        (newline-mark 10 [182 10])
        (tab-mark 9 [8594 9] [92 9])))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'prog-mode-hook
  (lambda ()
    (setq show-trailing-whitespace t)))
#+end_src

** Glasses

Glasses help reading Camel case. I prefer parentheses to stick to the
preceding identifier and embedded capitals to be downcase.

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load "glasses"
  (setq glasses-separate-parentheses-p nil
        glasses-uncapitalize-p t))
#+end_src

** Version control

I sometimes have directories both under [[http://subversion.apache.org/][Subversion]] and [[http://gitscm.org/][Git]]. As my
preferred version control backend is Git, the list of version control
backends must be reordered.

#+begin_src emacs-lisp :tangle init.el
(setq vc-handled-backends (cons 'Git (remove 'Git vc-handled-backends)))
#+end_src

Comparing revisions using Ediff is so pleasant that it deserves a key
binding, an alternative to the usefull =C-xvD= (binded to
=vc-root-diff=). Same remark for the command that grep in Git
repositories.

#+begin_src emacs-lisp :tangle init.el
(global-set-key "\C-xv=" 'ediff-revision)
(require 'vc-git)
(global-set-key "\C-xvG" 'vc-git-grep)
(global-set-key "\C-xvd" 'vc-dir-root)
#+end_src

Spell checking is automatically enabled when editing log messages,
whether working with Git or Subversion from a shell, or using Emacs
version control interface.

Note that, when working with Git from a shell, the buffer opened to
edit a log message has =default-generic-mode= enabled because its
content match =generic-find-file-regexp= and
=generic-use-find-file-hook= default value is =t= .

#+begin_src emacs-lisp :tangle init.el
(when has-spell-checker
  (add-hook 'find-file-hook
            (lambda ()
               (when (string-match "^svn-commit" (buffer-name))
                 (setq ispell-local-dictionary "english")
                 (flyspell-mode))))

  (add-hook 'default-generic-mode-hook
            (lambda ()
               (when (equal (buffer-name) "COMMIT_EDITMSG")
                 (setq ispell-local-dictionary "english")
                 (flyspell-mode))))

  (add-hook 'log-edit-mode-hook
            (lambda ()
               (setq ispell-local-dictionary "english")
               (flyspell-mode))))
#+end_src

Shorten the display of the current branch name in the modeline.

#+begin_src emacs-lisp :tangle init.el
(load-library "vc-hooks")
(defun vc-git-mode-line-string (file)
  "Return a string for `vc-mode-line' to put in the mode line for FILE."
  (let* ((rev (vc-working-revision file 'Git))
         (disp-rev (or (vc-git--symbolic-ref file)
                       (substring rev 0 7)))
         (short-rev (if (<= (length disp-rev) 8)
                        disp-rev
                      (concat (substring disp-rev 0 7) "…")))
         (def-ml (vc-default-mode-line-string 'Git file))
         (help-echo (get-text-property 0 'help-echo def-ml))
         (face   (get-text-property 0 'face def-ml)))
    (propertize short-rev
                'face face
                'help-echo (concat help-echo "\nCurrent revision: " rev))))
#+end_src

When using Git in an shell buffer I prefer not to have a pager
filtering the output.

#+begin_src emacs-lisp :tangle init.el
(setenv "GIT_PAGER" "")
#+end_src

While merging changes, when the last conflic is resolved, don't leave
automaticaly =smerge-mode=; Otherwise I tend to use =smerge-mode= key
bindings after the mode has been deactivated.

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load "smerge-mode"
  (setq smerge-auto-leave nil))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'vc-diff-finish-functions
	  #'(lambda ()
	      (when outline-minor-mode
		(outline-apply-default-state))))
#+end_src

** Command interpreter

#+begin_src emacs-lisp :tangle init.el
(add-hook 'comint-mode-hook
          (lambda ()
             (setq indicate-empty-lines nil)
             (define-key comint-mode-map "\C-c\C-k" 'comint-kill-subjob)
             (setq comint-terminfo-terminal "ansi")
             (when (eq system-type 'windows-nt)
               (setq comint-process-echoes 'on))))
#+end_src

** Interactive shell

#+begin_src emacs-lisp :tangle init.el
(add-hook 'shell-mode-hook
          (lambda ()
             (setq shell-font-lock-keywords nil)
             (goto-address-mode)))
#+end_src


An abbreviation is defined for =&> /dev/null=.

#+begin_src emacs-lisp :tangle init.el
(define-abbrev-table 'shell-mode-abbrev-table '(("null" "&> /dev/null")))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'sh-mode-hook
          (lambda ()
             (define-key sh-mode-map "'" 'self-insert-command)))
#+end_src

Make comint process output to interpret OSC commands and configure
Bash prompt to emit such commands to make sure default directory is
updated in shell buffers.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'comint-output-filter-functions #'comint-osc-process-output)
#+end_src

#+begin_src sh :tangle init_bash.sh
set -x
osc7_cwd() {
    printf "\e]7;file://%s%s\e\\" "$HOSTNAME" "$PWD"
}
PROMPT_COMMAND=${PROMPT_COMMAND:+$PROMPT_COMMAND; }osc7_cwd
set +x
#+end_src

** Terminal emulation

#+begin_src emacs-lisp :tangle init.el
(add-hook 'term-mode-hook
          (lambda ()
             (term-pager-toggle)))
#+end_src

** Compilation                                                     :noexport:

Colorize compilation output.

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'compilation-filter-hook #'ansi-color-compilation-filter)

  (add-hook 'compilation-mode-hook
            (lambda ()
               (setq truncate-partial-width-windows nil)
               (define-key compilation-mode-map "c" 'compile)))
#+end_src

*** TODO Send a D-BUS notification at the end of compilation       :noexport:

Only if the compilation was lengthy.

** Make

#+begin_src emacs-lisp :tangle init.el
(add-hook 'makefile-gmake-mode-hook
          (lambda ()
             (setq tab-width 3)))
#+end_src

** Visual interface to diff and patch

Prefer to run the visual interface to diff in a single frame and split
that frame vertically or horizontally according to the frame geometry.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'ediff-mode-hook
          (lambda ()
             (setq ediff-window-setup-function 'ediff-setup-windows-plain)
             (when (< (* 2 (frame-height)) (frame-width))
               (setq ediff-split-window-function 'split-window-horizontally))))
#+end_src

White space visualization is useful when inspecting diffs.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'diff-mode-hook
          (lambda ()
             (setq diff-font-lock-prettify t
                   outline-minor-mode-cycle t
                   outline-minor-mode-use-margins t)
             (whitespace-mode)
             (outline-minor-mode)))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'diff-mode-hook #'(lambda ()
			      (setq outline-default-state 1
				    outline-default-rules
				    '(subtree-is-long
				      subtree-has-long-lines
				      (match-regexp . "NEWS\\|test\\|package-lock\\.json\\|poetry\\.lock")))))
#+end_src

** Debugger, GDB

#+begin_src emacs-lisp :tangle init.el
(add-hook 'gdb-mode-hook
          (lambda ()
             (setq gdb-show-changed-values t
                   gdb-use-colon-colon-notation nil
                   gdb-use-separate-io-buffer t)))

(add-hook 'gud-mode-hook
          (lambda ()
             (setq gud-tooltip-mode nil
                   gud-gdb-command-name "gdb --silent --annotate=3")))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(defun alt-valgrind (file)
  (interactive "fEnter file: ")
  (shell-command (concat
                  "valgrind --leak-check=full  " file))
  (switch-to-buffer-other-window "*Shell Command Output*")
  (compilation-shell-minor-mode t))
#+end_src

** Support for C++

C++ developpers often name header files with the =.h= extension, like
C developpers. As I am more interested in C++, the default is to visit
such files in C++ mode. Whats more, candidate extensions for the
source file associated to a =.h= file are reordered to privilege C++
usual extensions rather than C ones (see =ff-find-other-file= binded
to =C-co= for a way to switch between implementation and declaration
on a file name basis).

#+begin_src emacs-lisp :tangle init.el
  (add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))

  (require 'find-file)
  (setcdr (assoc "\\.h\\'" cc-other-file-alist)
    (list (list ".cpp" ".cc" ".C" ".CC" ".cxx" ".c")))
#+end_src

Some abbreviation definitions for preprocessor directives are added.

#+begin_src emacs-lisp :tangle init.el
(define-skeleton cc-preprocessor-conditional-group
  "Insert a C preprocessor conditional group"
  "Group macro: " "#ifdef " str ?\n _ ?\n"#endif // " str ?\n)

(define-skeleton cc-preprocessor-not-conditional-group
  "Insert a C preprocessor conditional group"
  "Group macro: " "#ifndef " str ?\n _ ?\n"#endif // " str ?\n)

(define-skeleton cc-preprocessor-create-macro
  "Insert a C preprocessor macro creation"
  "Macro name: " "#define " str " " (skeleton-read "Macro expansion: ") _)

(define-skeleton cc-preprocessor-include-directive
  "Insert a C preprocessor include directive"
  "Header name: " "#include " str _)

(define-abbrev-table 'c++-ts-mode-abbrev-table
  '(("ppif" "" cc-preprocessor-conditional-group)
    ("ppnif" "" cc-preprocessor-not-conditional-group)
    ("ppd" "" cc-preprocessor-create-macro)
    ("ppi" "" cc-preprocessor-include-directive)))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'c++-ts-mode-hook
          (lambda ()
             (setq comment-style 'extra-line)
             (setq indent-tabs-mode nil)
             (define-key c++-ts-mode-map "\C-co" 'ff-find-other-file)
             (define-key c++-ts-mode-map "\C-m" 'c-context-line-break)))
#+end_src

Update default text to insert into new files.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'auto-insert-alist
             '(("\\.\\([Hh]\\|hh\\|hpp\\)\\'" . "C / C++ header")
  t "#pragma once\n\n"))
#+end_src

** Qt

 #+begin_src emacs-lisp :tangle init.el
(add-to-list 'auto-mode-alist '("\\.qrc\\'" . xml-mode))
(add-to-list 'auto-mode-alist '("\\.qss\\'" . css-mode))
 #+end_src

** Support for Emacs Lisp

#+begin_src emacs-lisp :tangle init.el
(add-hook 'emacs-lisp-mode-hook
          (lambda ()
             (set (make-local-variable 'comment-auto-fill-only-comments) t)
             (set (make-local-variable 'imenu-sort-function)
                  'imenu--sort-by-name)
             (define-key emacs-lisp-mode-map "\C-c\C-f"
               'emacs-lisp-byte-compile)))
#+end_src

To speedup Emacs Lisp execution, code can be compiled. The following
will compile a buffer on save if and only if an associated
byte-compiled file already exists.

#+begin_src emacs-lisp :tangle init.el
(defun byte-compile-current-buffer ()
  "Compile the current buffer if its major mode is
`emacs-lisp-mode' and an associated compiled file already
exists."
  (interactive)
  (when
      (and (eq major-mode 'emacs-lisp-mode)
           (file-exists-p (byte-compile-dest-file buffer-file-name)))
    (byte-compile-file buffer-file-name)))

(add-hook 'after-save-hook 'byte-compile-current-buffer)
#+end_src

** Support for Python

Some Linux distributions (e.g. Arch Linux) ship with both Python 2.x
and 3.x, thus the list of interpreters must be expanded accordingly
for file mode determination.

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load "python"
  (when (executable-find "python3")
    (setq python-shell-interpreter "python3")))
#+end_src

The style used for docstring is the one found in Django code source.

#+begin_src emacs-lisp :tangle init.el
  (add-hook 'python-ts-mode-hook
            (lambda ()
               (setq tab-width 4
                     gud-pdb-command-name (concat python-shell-interpreter " -m pdb ")
                     python-fill-docstring-style 'pep-257)))
#+end_src

The Python documentation used to be distributed in Texinfo format. It
is not the case anymore since the documentation is handled by the
Sphinx framework. But it is still possible to generate Texinfo files
using Sphinx; Such files are easy to find on the web (if you don't
want to generate them by yourself...). The =info-look= setting for
=python-mode= must be updated to those new files.

#+begin_src emacs-lisp :tangle init.el
(with-eval-after-load "info-look"
  (info-lookup-add-help
    :mode 'python-ts-mode
    :regexp "[[:alnum:]_]+"
    :doc-spec '(("(python)Index" nil ""))))
#+end_src

Usefull abbreviations.

#+begin_src emacs-lisp :tangle init.el
(define-abbrev-table 'python-mode-abbrev-table
  '(("pdb" "import pdb; pdb.set_trace()")))
#+end_src

Set the name of the Python template to insert at file creation.

#+begin_src emacs-lisp :tangle init.el
(let ((filename "python_template.py"))
  (when (file-exists-p (expand-file-name filename auto-insert-directory))
    (add-to-list 'auto-insert-alist
                 `(python-ts-mode . ,filename))))
#+end_src

** Support for Scheme

#+begin_src emacs-lisp :tangle init.el
(add-hook 'scheme-mode-hook
          (lambda ()
             (setq scheme-program-name "umb-scheme")))
#+end_src

** Support for JavaScript

#+begin_src emacs-lisp :tangle init.el
(add-hook 'js-ts-mode-hook
          (lambda ()
             (setq indent-tabs-mode nil)
             (subword-mode)))
#+end_src

** Support for SQL

Hitting =;= in an interactive SQL buffer will send the current input
to the process.

#+begin_src emacs-lisp :tangle init.el
(setq sql-electric-stuff t)
#+end_src

** Support for PHP

#+begin_src emacs-lisp :tangle init.el
(when (locate-library "php-mode")
  (load-library "php-mode")
  (add-hook 'php-mode-hook 'flymake-mode))
#+end_src

* Text edition

#+begin_src emacs-lisp :tangle init.el
(add-hook 'text-mode-hook
          (lambda ()
             (goto-address-mode)
             (flyspell-mode)))
#+end_src

Insert double angle quotation marks in pairs.

#+begin_src emacs-lisp :tangle init.el
(add-to-list 'electric-pair-text-pairs
	     '(171 . 187))
#+end_src

** Support for SGML, HTML, CSS

It is difficult to avoid long lines when writing SGML files, thus
automatic line breaking is turned off.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'html-mode-hook
          (lambda ()
             (auto-fill-mode -1)
             (abbrev-mode)
             (when has-spell-checker
               (flyspell-mode))))
#+end_src

An abbreviation is defined for the Lorem Ipsum.

#+begin_src emacs-lisp :tangle init.el
(define-abbrev-table 'html-mode-abbrev-table
  '(("lorem"
     "<p>Lorem ipsum dolor sit amet, consectetur adipisicing
elit, sed do eiusmod tempor incididunt ut labore et dolore magna
aliqua. Ut enim ad minim veniam, quis nostrud exercitation
ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis
aute irure dolor in reprehenderit in voluptate velit esse cillum
dolore eu fugiat nulla pariatur. Excepteur sint occaecat
cupidatat non proident, sunt in culpa qui officia deserunt mollit
anim id est laborum.</p>")))
#+end_src

When available, load the package =flymake-csslint= to check code on the
fly.

#+begin_src emacs-lisp :tangle init.el
(when (locate-library "flymake-csslint")
  (require 'flymake-csslint)
  (add-hook 'css-mode-hook 'flymake-mode))
#+end_src

When available, load the package =irfc= providing an interface to IETF
RFC documents.

#+begin_src emacs-lisp :tangle init.el
(when (locate-library "irfc")
  (require 'irfc)
  (setq irfc-assoc-mode t))
#+end_src

When available, load the package =rainbow-mode= to colorize strings
that represent colors.

#+begin_src emacs-lisp :tangle init.el
(when (locate-library "rainbow-mode")
  (require 'rainbow-mode)
  (add-hook 'css-mode-hook 'rainbow-mode))
#+end_src

** Support for MarkDown

#+begin_src emacs-lisp :tangle init.el
  (when (locate-library "markdown-mode")
    (load-library "markdown-mode")
    (add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode)))

#+end_src

** Support for TeX and LaTeX

When a file with =.tex= extension is opened, it is parsed to identify
if it is a TeX or a LaTeX file. The latter will be the default if the
parsing fails to identify whether it is a TeX or a LaTeX file. Next,
the list of regions to be skipped while spell checking a buffer in TeX
mode is extended (most of the time =\ref= and =\label= parameters are
acronyms not recognized by the spell checker).

#+begin_src emacs-lisp :tangle init.el
(setq tex-default-mode 'latex-mode)
(setq ispell-tex-skip-alists
      (cons
       (let ((list (car ispell-tex-skip-alists)))
         (add-to-list 'list '("\\\\\\(ref\\|label\\)" ispell-tex-arg-end)))
       (cdr ispell-tex-skip-alists)))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(setq latex-run-command "latex -synctex=1 -interaction=nonstopmode")
(add-hook 'latex-mode-hook
          (lambda ()
             (setq comment-style 'plain
                   comment-column 0
                   indent-tabs-mode nil
                   ispell-check-comments nil
                   tex-trailer "\\end{document}"
                   latex-block-default "theorem"
                   latex-block-names
                   '("theorem" "proposition" "definition" "lemma" "multline")
                   tex-open-quote "\\og "
                   tex-close-quote "\\fg"
                   tex-alt-dvi-view-command
                   `(let ((line (count-lines 1 (point)))
                          (source (file-name-nondirectory (buffer-file-name))))
                      (concat "xdvi -sourceposition "
                              (number-to-string line) source " *")))
             (define-skeleton alt-latex-math-env
               "Create a matching pair of parenthesis."
               nil 92 40 _ 92 41)
             (define-skeleton alt-latex-displaymath-env
               "Create a matching pair of brackets."
               nil 92 91 _ 92 93)
             (add-to-list 'tex-compile-commands
                          '("xdg-open %r.pdf &" "%r.pdf"))
             (reftex-mode t)
             (outline-minor-mode 1)
             (define-key latex-mode-map [M-tab] 'info-complete-symbol)
             (define-key latex-mode-map "\C-c\C-s" 'alt-latex-section)
             (define-key latex-mode-map "\C-cm" 'alt-latex-math-env)
             (define-key latex-mode-map "\C-cM" 'alt-latex-displaymath-env)))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'tex-shell-hook
          (lambda ()
             (add-to-list 'shell-font-lock-keywords
                    '("^\\(LaTeX Warning:\\|\\!\\)" . font-lock-warning-face))
             (define-key tex-shell-map "\C-c\C-p" 'comint-previous-prompt)))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(defun alt-auto-insert-latex ()
  "Ask the user for a LaTeX class and a language name, then
insert the corresponding template file in current buffer.

The relative name of the template file is LaTeX/CLASS-LANG.tex or
LaTeX/CLASS.tex if language is empty. This file is taken in the
directory `auto-insert-directory'.

If class is empty, the current buffer is expected to belong to a
multi-file document; The user is asked for the name of the main
document, then a skeleton with a reference to that name is
inserted."
  (let* ((class (completing-read "Document class: "
                                 '(("article" 1) ("report" 2) ("book" 3)
                                   ("letter" 4) ("slides" 5) ("exam" 6))))
         (lang (when (not (equal class ""))
                 (completing-read "Main language: "
                                  '(("french" 1) ("english" 2))))))
    (if (not (equal class ""))
        (let ((name (expand-file-name
                     (concat auto-insert-directory "LaTeX/" class
                             (when (not (equal lang ""))
                               (concat "-" lang)) ".tex"))))
          (if (file-readable-p name)
              (progn
                (insert "% Time-stamp: <" (current-time-string)
                        " " (user-login-name) ">\n% Author: "
                        (user-full-name) " <" (progn user-mail-address) ">\n\n")
                (insert-file-contents name))
            (message "No template file %s found" name)))
      (let ((name (read-file-name "Main file: " default-directory "")))
        (insert "% Time-stamp: <" (current-time-string)
                " " (user-login-name) ">\n% Author: " (user-full-name)
                " <" (progn user-mail-address) ">\n\n")
        (goto-char (point))
        (when (not (equal name ""))
          (save-excursion
            (insert "\n\n% Local Variables:\n% tex-main-file: \""
                    name "\"\n% End:\n")))))))

(add-to-list 'auto-insert-alist
             '(latex-mode . alt-auto-insert-latex))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'reftex-mode-hook
          (lambda ()
             (setq reftex-extra-bindings t
                   reftex-enable-partial-scans t
                   reftex-save-parse-info nil
                   reftex-use-multiple-selection-buffers t
                   reftex-label-alist
                   (setq reftex-label-alist
                         '(("theorem" ?h "thr:" "~\\ref{%s}" t
                            (regexp "th\\\(\\\(é\\\|\'e\\\)or\\\(è\\\|\`e\\\)mes?\\\|m\\\.\\\)") nil)
                           ("proposition" ?p "pro:" "~\\ref{%s}" t
                            (regexp "prop\\\(ositions?\\\|.\\\)") nil)
                           ("lemma" ?l "lem:" "~\\ref{%s}" t
                            (regexp "lem\\\(mes?\\\|.\\\)") nil)
                           ("equation" 101 "eq:" "~(\\ref{%s})" t
                            (regexp "\\\(l'\\\)?\\\(é\\\|\'e\\\)quations?") nil)
                           ("example" ?x "exm:" "~\\ref{%s}" t
                            (regexp "exemp\\\(les?\\\|.\\\)")))))
             (defun reftex-page-reference ()
               "Make a LaTeX reference to a page number."
               (interactive)
               (let ((reftex-format-ref-function
                      `(lambda (label format)
                         (concat "~\\pageref{" label "}"))))
                 (reftex-reference)))
             (define-key reftex-mode-map "\C-c]" 'reftex-page-reference)
             (define-key-after reftex-mode-menu [pageref]
               '(menu-item "\\pageref" reftex-page-reference) '\\cite)))

(with-eval-after-load "reftex"
  (let ((dir (expand-file-name "~/Documents/Mathématiques/Bibliographie")))
    (when (file-exists-p dir)
      (dolist (name (directory-files dir t ".*\.bib$"))
        (add-to-list 'reftex-default-bibliography name)))))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(defcustom latex-outline-max-level 4
  "Maximum level of outline headings used by imenu."
  :type 'integer
  :group 'tex)
#+end_src

#+begin_src emacs-lisp :tangle init.el
(defadvice latex-imenu-create-index (before cut-section-alist activate)
  "Cut `latex-section-alist' to have max `latex-outline-max-level' in
`imenu' menu."
  (setq temp-latex-section-alist latex-section-alist)
  (set (make-local-variable 'latex-section-alist)
       (let (list)
         (dolist (elt (default-value 'latex-section-alist))
           (if (<= (cdr elt) latex-outline-max-level)
               (push elt list)))
         list)))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(defadvice latex-imenu-create-index (before cut-metasection-list activate)
  "Cut `latex-metasection-alist' to get rid of \\end{document} entries
in `imenu' menu."
  (setq temp-latex-metasection-list latex-metasection-list)
  (set (make-local-variable 'latex-metasection-list)
       (remove "end{document}" latex-metasection-list)))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(defadvice latex-imenu-create-index
  (after restore-latex-metasection-list activate)
  "Restore `latex-metasection-list' default value."
  (setq latex-metasection-list temp-latex-metasection-list))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(defadvice latex-imenu-create-index
  (after restore-latex-section-alist activate)
  "Restore `latex-section-alist' default value."
  (setq latex-section-alist temp-latex-section-alist))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(defvar tex-alt-dvi-view-command nil)

(defun alt-tex-view (&optional alt)
  "Like \\[tex-view] but allows use of alternative command.

If prefix argument is provided, use the alternative command,
`tex-alt-dvi-view-command'."
  (interactive "P")
  (or tex-dvi-view-command
      (error "You must set `tex-dvi-view-command'"))
  (let ((tex-dvi-print-command
         (if alt tex-alt-dvi-view-command
           tex-dvi-view-command)))
    (tex-print)))

(defvar alt-latex-section-default "paragraph")

(define-skeleton alt-latex-section
  "Create a sectionning command \\SECTION{TITLE} at point."
  (let ((section (completing-read
                  (format "LaTeX section name [%s]: "
                          alt-latex-section-default)
                  latex-section-alist nil nil nil nil
                  alt-latex-section-default)))
    (setq alt-latex-section-default section))
  \n "\\" str ?\{ (skeleton-read "Title: ") ?\} \n \n)
#+end_src

** Support for dict protocol

#+begin_src emacs-lisp :tangle init.el
(when (locate-library "dictionary")
  (load-library "dictionary")
  (define-key dictionary-mode-map [backtab] 'dictionary-prev-link))
#+end_src

** Support for reStructuredText

Auto fill mode may break the indentation.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'rst-mode-hook
          (lambda ()
            (auto-fill-mode -1)))

(let ((filename "template.rst"))
  (when (file-exists-p (expand-file-name filename auto-insert-directory))
    (add-to-list 'auto-insert-alist
                 `(rst-mode . ,filename))))
#+end_src
** Org mode

#+begin_src emacs-lisp :tangle init.el
(setq org-hide-leading-stars t
      org-log-done 'time
      org-directory (expand-file-name "~/Documents/Notes/")
      org-default-notes-file (expand-file-name "todo.org" org-directory))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(when (featurep 'windmove)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(define-key global-map "\C-cr" 'org-capture)
(define-key global-map "\C-ca" 'org-agenda)
#+end_src

Org files have an option to set the language to use for translations
while exporting to HTML. When this option is set, one can deduce the
dictionary to use for spell checking. By the way I like to spell check
Org buffers on the fly.

#+begin_src emacs-lisp :tangle init.el
(when has-spell-checker
  (add-hook 'org-mode-hook
   (lambda ()
      (require 'ispell)
      (ispell-set-spellchecker-params)
      (require 'ox)
      (let ((lang (plist-get (org-export-get-environment) :language)))
        (when (and lang (assoc lang ispell-dictionary-alist))
          (setq ispell-local-dictionary lang)))
      (flyspell-mode))))
#+end_src

Various types of capture items are defined.

#+begin_src emacs-lisp :tangle init.el
(require 'org-capture)
(add-to-list 'org-capture-templates
      '("t" "Todo" entry (file+headline "todo.org" "Tasks")
        "* TODO %?\n  %i\n  %a"))
#+end_src

* File management

** Replace deletion by move to trash

#+begin_src emacs-lisp :tangle init.el
(setq delete-by-moving-to-trash t)
#+end_src

** Jumping and viewing

#+begin_src emacs-lisp :tangle init.el
(autoload 'dired-jump "dired" "\
     Jump to Dired buffer corresponding to current buffer.
     If in a file, Dired the current directory and move to file's line.
     If in Dired already, pop up a level and goto old directory's line.
     In case the proper Dired file line cannot be found, refresh the Dired
     buffer and try again." t nil)

(autoload 'dired-jump-other-window "dired" "\
     Like \\[dired-jump] (dired-jump) but in other window." t nil)

(define-key ctl-x-map "\C-j" 'dired-jump)

(define-key ctl-x-4-map "\C-j" 'dired-jump-other-window)
(define-key ctl-x-4-map "v" 'view-file-other-window)

(define-key ctl-x-5-map "v" 'view-file-other-frame)
(define-key ctl-x-5-map "c" 'alt-clone-indirect-buffer-other-frame)
#+end_src

** Enhancing file manager

#+begin_src emacs-lisp :tangle init.el
(add-hook 'dired-load-hook
          (lambda ()
             (require 'dired-x)
             (setq dired-x-hands-off-my-keys nil)
             (dired-x-bind-find-file)
             (setq dired-free-space-args "-Pk"
                   dired-listing-switches "-al")
             (setq dired-isearch-filenames t
                   dired-vc-rename-file t)))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(when (locate-library "gnus-dired")
  (require 'gnus-dired))

(let ((system-type))
  (cond
   ('windows-nt
    (setq dired-omit-files
      (concat dired-omit-files
              "\\|^\\..+\\|^CVS$\\|^\\$Recycle\\.Bin$")))
   (t (setq dired-omit-files
      (concat dired-omit-files
              "\\|^\\..+\\|^CVS$\\|^lost\\+found")))))
(setq dired-omit-files
  (concat dired-omit-files "\\|^__pycache__$" "\\|^\.mypy_cache$"))
(add-to-list 'dired-omit-extensions ".egg-info")
(setq dired-omit-extensions (delete ".pdf" dired-omit-extensions))
(add-hook 'dired-mode-hook
          (lambda ()
             (when (fboundp 'gnus-dired-mode)
               (gnus-dired-mode 1))
             (setq dired-omit-size-limit nil
                   truncate-lines t)
             (dired-omit-mode 1)
             (dired-hide-details-mode 1)
             (set (make-local-variable 'transient-mark-mode) nil)
             (define-key dired-mode-map "w" 'dired-copy-filename-as-kill)))
#+end_src

* Mail, newsgroup, RSS

** Usenet, RSS and electronic mail

I use Gnus for Usenet forums, RSS feeds and electronic mail. All
configuration files goes into =~/.config/emacs=.

#+begin_src emacs-lisp :tangle init.el
(setq read-mail-command 'gnus
      mail-user-agent 'gnus-user-agent
      message-directory (expand-file-name "~/.config/emacs/Mail")
      gnus-home-directory (expand-file-name "~/.config/emacs/"))
#+end_src

Quit reading news before killing emacs.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'kill-emacs-hook
          (lambda ()
             (when (and (fboundp 'gnus-alive-p) (gnus-alive-p))
               (gnus-group-exit))))
#+end_src

Group topics are enabled by default.

#+begin_src emacs-lisp :tangle init.el
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
#+end_src

Maill servers are scanned every 2 minutes.

#+begin_src emacs-lisp :tangle init.el
(require 'gnus-demon)
(gnus-demon-add-scanmail)
#+end_src

#+begin_src emacs-lisp :tangle .gnus.el
(setq gnus-nntp-server nil
      gnus-select-method
      '(nnimap "gmail"
               (nnimap-address "imap.gmail.com")
               (nnimap-server-port "imaps")
               (nnimap-stream ssl))
      gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")

(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
      smtpmail-auth-credentials '(("smtp.gmail.com" 587 "orontee@gmail.com" nil))
      smtpmail-default-smtp-server "smtp.gmail.com"
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 587
      smtpmail-local-domain "localdomain")
#+end_src

To view images using Eye Of Gnome I have created the file:~/.mailcap
with the following content.

#+begin_src
image/jpeg; eog %s
#+end_src

Atom feeds must be converted before Gnus can parsed them. The
file:~/.config/emacs/atom2rss.xsl can be downloaded from
http://atom.geekhood.net/.

#+begin_src
(require 'mm-url)
(defadvice mm-url-insert (after DE-convert-atom-to-rss () )
  "Converts atom to RSS by calling xsltproc."
  (when (re-search-forward "xmlns=\"http://www.w3.org/.*/Atom\""
                           nil t)
    (goto-char (point-min))
    (message "Converting Atom to RSS... ")
    (call-process-region (point-min) (point-max)
                         "xsltproc"
                         t t nil
                         (expand-file-name "~/.config/emacs/atom2rss.xsl") "-")
    (goto-char (point-min))
    (message "Converting Atom to RSS... done")))

(ad-activate 'mm-url-insert)
#+end_src

** Message writing

#+begin_src emacs-lisp :tangle init.el
(setq user-mail-address "orontee@gmail.com"
      user-full-name "Matthias Meulien")
#+end_src

#+begin_src emacs-lisp :tangle init.el
(add-hook 'message-mode-hook
          (lambda ()
             (setq message-elide-ellipsis "\n> (...)\n"
                   message-signature t)
             (setq message-completion-alist
                   '(("^\\(Newsgroups\\|Followup-To\\|Posted-To\\|Gcc\\):" . message-expand-group)
                     ("^\\(Resent-\\)?\\(To\\|B?Cc\\):" . eudc-expand-inline)
                     ("^\\(Reply-To\\|From\\|Mail-Followup-To\\|Mail-Copies-To\\):" . eudc-expand-inline)
                     ("^\\(Disposition-Notification-To\\|Return-Receipt-To\\):" . message-expand-name)))
             (setq ispell-message-dictionary-alist
                   '(("^To:[^\n,]+\\.fr[ \t\n,>]" . "francais")
                     ("^Newsgroups:[ \t]*fr\\." . "francais")
                     ("^Newsgroups:[ \t]*[^f]" . "english")))))
#+end_src

#+begin_src emacs-lisp :tangle init.el
(setq gnus-posting-styles
      '((".*"
         (signature "Matthias"))))
#+end_src

* Code sources                                                             :noexport:

#+name: init.el_header
#+begin_src emacs-lisp
;;; -*- coding: utf-8; -*-
;;; GNU Emacs Startup file

;;; WARNING This file was automatically generated: Do not edit
#+end_src

#+name: init.el_custom-file_loading
#+begin_src emacs-lisp :tangle init.el
(require 'cus-edit)
(setq custom-file (expand-file-name
                   (concat  "~/.config/emacs/" system-name "-custom.el")))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

#+name: init.el_system-name_loading
#+begin_src emacs-lisp :tangle init.el
(let ((file (locate-library (concat (system-name) ".el"))))
  (if file
      (load file t)
    (message "No machine specific initialization")))
#+end_src

# Local Variables:
# Mode: org
# End:
