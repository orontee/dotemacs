An Emacs configuration tour

#+startup: overview
#+language: en
#+drawers: PROPERTIES FEEDSTATUS
#+filetags: emacs
#+todo: TODO | DONE CANCELED
#+style: <link rel="stylesheet" type="text/css" href="css/clean.css" />
#+options: H:2 toc:nil todo:t email:t ^:nil

* Introduction

I am using [[http://www.gnu.org/software/emacs/][GNU Emacs]] since the late '90 on various environments, both
at home or at work. At the beginning, I used it to write LaTeX files:
I found that tool more or less randomly while sitting in front of one
of the X Window terminals of my university. Today, whatever I have to
do with a computer, it ends in an Emacs buffer... In my current use,
Emacs has become a kind of interface over the computer's operating
system (whatever it is: Arch Linux, Ubuntu, Windows XP and Vista). But
suprisingly I feel like it has adapt to my needs rather than I have
limited myself to its features.

As an intensive Emacs user I had various needs related to Emacs
customization: Centralize all customization to be able to deploy
efficiently on multiple targets; Organize Emacs customization in the
order demanded by the flow of my needs rather than the one imposed by
the computer; Share Emacs customization; Gather links to external
tools; Log my contributions; Etc. Thus I have written an Org file
whose code blocks could be converted to the source file I use to
customize Emacs to my needs and, on the other hand, is the source of
the documentation you are reading.

*Downloads*

You can download both the [[file:README.org][Org file]] and build a file:.emacs using
=GNU Make=.

*References*

Most of the following code snippets I have written myself. Some were
copied from the [[https://lists.gnu.org/mailman/listinfo/help-gnu-emacs][gnu.emacs.help newsgroup]] or the [[http://www.emacswiki.org/][Emacs wiki]].

* General use
** Header							   :noexport:

#+begin_src emacs-lisp :tangle .emacs :noweb tangle
<<.emacs_header>>
#+end_src

** Checking emacs version

Despite a common misconception, GNU Emacs is actively maintained and
last versions were greatly improved. A recent version is required. It
can be downloaded from http://ftp.gnu.org/pub/gnu/emacs/.

#+begin_src emacs-lisp :tangle .emacs
(when (or (< emacs-major-version 24)
          (and (= emacs-major-version 24)
               (< emacs-minor-version 3)))
  (error "Wrong Emacs version, update or remove the configuration
  file"))
#+end_src

** Extending Emacs, packages repositories, etc

The easiest way to extend Emacs features is to use =list-package= and
install packages from remote repositories. But =package.el= is rather
new and not all libraries are available in the form of packages. When
a library must be installed by hand, a good practice is to always put
it in the directory =~/.emacs.d/lisp=. The load path is extended
accordingly.

#+begin_src emacs-lisp :tangle .emacs
(add-to-list 'load-path (expand-file-name "~/.emacs.d/lisp/"))
#+end_src

The default is to fetch packages from the GNU Emacs packages
repository. There are usefull packages in other places like [[http://tromey.com/elpa/][ELPA]] and
[[http://marmalade-repo.org/][Marmalade]].

#+begin_src emacs-lisp :tangle .emacs
(eval-after-load "package"
  '(progn
     (add-to-list 'package-archives '("marmalade". "http://marmalade-repo.org/packages/"))))
(package-initialize)
#+end_src

At the time of writing, I have activated the following packages:

#+begin_src emacs-lisp :exports results :results value raw
(let ((descriptions "|Package|Description|\n|---|\n"))
  (dolist (package package-alist descriptions)
    (let ((name (car package))
	  (desc (aref (cdr package) 2)))
    (setq descriptions 
	  (concat descriptions (format "|%s|%s|\n" name desc))))))
#+end_src

#+RESULTS:
| Package                 | Description                                                        |
|-------------------------+--------------------------------------------------------------------|
| gist                    | Emacs integration for gist.github.com                              |
| gh                      | A GitHub library for Emacs                                         |
| pcache                  | persistent caching for Emacs                                       |
| logito                  | logging library for Emacs                                          |
| symbols-mode            | List symbols of object files                                       |
| python-django           | A Jazzy package for managing Django projects                       |
| popup                   | Visual Popup User Interface                                        |
| php-mode                | major mode for editing PHP code                                    |
| pastebin                | A simple interface to the www.pastebin.com webservice              |
| mode-icons              | Show icons for modes                                               |
| htmlize                 | Convert buffer text and decorations to HTML.                       |
| graphviz-dot-mode       | Mode for the dot-language used by graphviz (att).                  |
| gnuplot                 | drive gnuplot from within emacs                                    |
| flymake-python-pyflakes | A flymake handler for python-mode files using pyflakes (or flake8) |
| flymake-jslint          | A flymake handler for javascript using jslint                      |
| flymake-easy            | Helpers for easily building flymake checkers                       |
| flymake-csslint         | making flymake work with CSSLint                                   |
| doctags                 | Generation of tags documentation in Doxygen syntax                 |
| color-theme-solarized   | Solarized themes for Emacs                                         |
| auto-complete           | Auto Completion for GNU Emacs                                      |
| Django-doc              | Info documentation for Django                                      |

All settings written using the customize library go to a dedicated
file that is loaded when the loading of the [[file:.emacs][configuration file]] ends.

#+begin_src emacs-lisp :noweb yes
<<.emacs_custom-file_loading>>
#+end_src

When the custom settings are loaded, a machine specific file is
loaded. The file name comes from the host name of the machine Emacs is
running on.

#+begin_src emacs-lisp :noweb yes
<<.emacs_system-name_loading>>
#+end_src

** Widening the screen

You feel like the computer screen is too narrow, don't you? So menu
bars, scroll bars and tool bars must be disabled. Whats more,
disabling this eyecandy may improve responsiveness when Emacs run on a
remote computer forwarding X11. Note that the content of the menu bar
is still available by pressing =f10= or the contextual menu bind to
=C-mouse-1=.

#+begin_src emacs-lisp :tangle .emacs
(when (fboundp 'menu-bar-mode) (menu-bar-mode -1))
(when (fboundp 'scroll-bar-mode) (scroll-bar-mode -1))
(when (fboundp 'horizontal-scroll-bar-mode) (horizontal-scroll-bar-mode -1))
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
#+end_src

Don't know how to scroll buffers now that the scrollbar is gone? Read
the descriptions of the following key bindings: =M-v=, =C-v=, =M-C-v=,
=S-M-C-v=, =C-l=, =C-M-l=, =<prior>=, =<next>=, etc. Why should we add
scrollbars? By the way, the mode line indicates the percentage of the
buffer above the top of the window. And the column number is available
from the output of =C-x== (bind to =what-cursor-position=).

Another way to widen the screen is to truncate long lines and change
the text scale in secondary buffers. Restoring or changing the text
scale can be done interactively with =C-xC-0=, =C-xC-+= and =C-xC-=.

#+begin_src emacs-lisp :tangle .emacs
(when (require 'face-remap)
  (dolist (hook '(gdb-breakpoints-mode-hook gdb-inferior-io-mode-hook
                                            gdb-mode-hook gdb-locals-mode-hook gdb-frames-mode-hook
                                            speedbar-mode-hook vc-dir-mode-hook
                                            occur-mode-hook apropos-mode-hook grep-mode-hook))
    (add-hook hook
              (lambda ()
                (setq truncate-lines t)
                (when (not text-scale-mode)
                  (text-scale-set -1))))))
(add-hook 'compilation-mode-hook
  (lambda ()
    (when (not text-scale-mode)
      (text-scale-set -1))))
#+end_src

** Generic modes

From the docstring: Generic modes provide basic comment and font-lock
functionality for "generic" files. (Files which are too small to
warrant their own mode, but have comment characters, keywords, and the
like.)

The file =generic-x.el= contains a collection of generic modes. The
default is to enable generic modes according to the host operating
system; I prefer to always define MS Windows generic modes for I
sometime have to work on script files for the MS Windows command
line...

#+begin_src emacs-lisp :tangle .emacs
(load "generic-x")
(setq generic-extras-enable-list
      (append generic-default-modes
	      generic-mswindows-modes
	      generic-unix-modes))
(load "generic-x")
#+end_src

The =systemd= configuration files are Conf files.

#+begin_src emacs-lisp :tangle .emacs
(when (eq system-type 'gnu/linux)
  (add-to-list 'auto-mode-alist
               '("\\.service\\'" . conf-mode)))
#+end_src

Bind =rc-generic-mode= to Visual Studio Resource files.

#+begin_src emacs-lisp :tangle .emacs
(add-to-list 'auto-mode-alist
             '("\\.rc2\\'" . rc-generic-mode))
#+end_src

** Auto insertion at file creation

Auto insertion of templates at file creation is enabled and the
location where templates are searched is defined.

#+begin_src emacs-lisp :tangle .emacs
(auto-insert-mode)
(let ((file (expand-file-name "~/Modèles")))
  (when (file-exists-p file)
    (setq auto-insert-directory file)))
#+end_src

** Revert buffers on file changes

Reverts any buffer associated with a file when the file changes on
disk. For files with =.log= extension, the tail is constantly
followed.

#+begin_src emacs-lisp :tangle .emacs
(global-auto-revert-mode)

(add-hook 'find-file-hook
          (lambda()
             (when (and (buffer-file-name)
                        (equal (file-name-extension (buffer-file-name)) "log"))
               (auto-revert-tail-mode))))
#+end_src

** Moving between windows and selecting buffers

Usually the frame is split at most twice. I find =C-xo= sufficient to
change the selected window along the three candidates.\

To select a buffer I often use =C-xb= and completion. When my brain
can't remember the buffer name, I use the default buffer menu
(accessible from =C-xC-b= and =C-uC-xC-b=) or =icomplete-mode=. That's
all. No =ido=, =icycle=, etc.

#+begin_src emacs-lisp :tangle .emacs
(icomplete-mode 1)
(setq confirm-nonexistent-file-or-buffer t)
#+end_src

When I am working on multiple projects, I switch of windows
configurations using registers (use =C-xrw= to store a window
configuration in a register and =C-xrj= to jump back to it). But
registers are named against single characters, so I need twice
thinking before storing a new configuration. The following
redefinition of =window-configuration-to-register= ask the user to
confirm the overwrite when storing a configuration in a register
already containing a window configuration.

#+begin_src emacs-lisp :tangle .emacs
(defun window-configuration-to-register (register &optional _arg)
  "Like `window-configuration-to-register' but warn the user that
he is about to overwrite a window configuration."
  (interactive "cWindow configuration to register: \nP")
  (let ((val (get-register register)))
    (cond
     ((or (not (consp val))
	      (not (frame-configuration-p (car val)))
	      (yes-or-no-p "Overwrite window configuration? "))
      (set-register register
		    (list (current-frame-configuration) (point-marker))))
     (t
      (error "Register already contains a window configuration")))))
#+end_src

** Empty scratch buffer

#+begin_src emacs-lisp :tangle .emacs
(setq initial-scratch-message nil)
#+end_src

** Diary and calendar customization

A diary file is automatically created.

#+begin_src emacs-lisp :tangle .emacs
(let ((file (expand-file-name "~/.emacs.d/diary")))
  (when (not (file-exists-p file))
    (write-region "" nil file))
  (setq diary-file file))
#+end_src

The calendar is configured to match the french standards.

#+begin_src emacs-lisp :tangle .emacs
(setq european-calendar-style t
      calendar-time-display-form 
      '(24-hours ":" minutes
		 (if time-zone " (") time-zone (if time-zone ")"))
      calendar-week-start-day 1
      calendar-intermonth-text
      '(propertize
	(format "%2d"
		(car
		 (calendar-iso-from-absolute
		  (calendar-absolute-from-gregorian (list month day year)))))
	'font-lock-face 'font-lock-function-name-face))

(setq view-diary-entries-initially t
      number-of-diary-entries [0 2 2 2 2 4 1]
      mark-diary-entries-in-calendar t
      view-calendar-holidays-initially nil
      mark-holidays-in-calendar t
      general-holidays nil
      hebrew-holidays nil
      all-christian-calendar-holidays t
      islamic-holidays nil
      oriental-holidays nil)

(add-hook 'today-visible-calendar-hook 'calendar-mark-today)

(add-hook 'diary-display-hook 'fancy-diary-display)
#+end_src

French holidays are be added to the calendar. Note that Christian
holidays are already present into the calendar since we have set
=all-christian-calendar-holidays= to =t=.

#+begin_src emacs-lisp :tangle .emacs
(setq french-holiday
      '((holiday-fixed 1 1 "Jour de l'an")
        (holiday-fixed 5 1 "Fête du travail")
        (holiday-fixed 5 8 "Victoire 1945")
        (holiday-fixed 7 14 "Fête nationale")
        (holiday-fixed 11 1 "Toussaint")
        (holiday-fixed 11 11 "Armistice 1918")))

(setq holiday-other-holidays 
      (append french-holiday holiday-other-holidays))
#+end_src

** Electric modes

Enable pairing to insert pairs of matching characters.

#+begin_src emacs-lisp :tangle .emacs
(electric-pair-mode)
#+end_src

** Save place

Automatically save place of cursor in each file.

#+begin_src emacs-lisp :tangle .emacs
(setq-default save-place t)
(require 'saveplace)
#+end_src

** Archives display

#+begin_src emacs-lisp :tangle .emacs
(require 'tar-mode)
(setq tar-mode-show-date t)
#+end_src

** Time and date

When working in a console, it is sometime usefull to get the time:
=M-! date= is ok for this. To display the time in the modeline there
is =display-time-mode=.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'display-time-mode-hook
	  (lambda ()
	     (setq display-time-day-and-date nil
		   display-time-24hr-format t 
		   display-time-use-mail-icon nil
		   display-time-format "%A,%e %B %Y %R")))
#+end_src

** Syntax highlighting

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'font-lock-mode-hook
	  (lambda ()
	     (show-paren-mode)))

(add-hook 'show-paren-mode-hook
	  (lambda ()
	     (setq show-paren-style 'parenthesis)))
#+end_src

** Final new line

All files will have a newline at their end.

#+begin_src emacs-lisp :tangle .emacs
(setq require-final-newline t)
#+end_src

** Language environment

The preferred input method is set according to the current language
environment. I prefer to use prefix modifiers (use =C-hI= to get a
description of any input method). Note that the default language
environment is set during startup, before the user init file is
loaded; It explains the explicit call to our
=choose-language-input-method=.

#+begin_src emacs-lisp :tangle .emacs
(defun choose-language-input-method ()
  "Set default input method according to current language
environment."
  (let* ((language-name current-language-environment)
         (method (cond
                  ((string= language-name "French")
                   'french-prefix)
                  ((or (string= language-name "Latin-1")
                       (string= language-name "UTF-8"))
                   'latin-1-prefix)
                  (t nil))))
    (setq default-input-method method)))

(add-hook 'set-language-environment-hook
          (lambda ()
            (choose-language-input-method)))

(choose-language-input-method)
#+end_src

But there are other input methods I use: For example the TeX method.
Key sequences are defined to easily set the input methods I need.

#+begin_src emacs-lisp :tangle .emacs
(dolist (elt '(("1" . "latin-1-prefix")
	       ("9" . "latin-9-prefix")
	       ("u" . "TeX")))
  (define-key mule-keymap (car elt)
    `(lambda ()
       (interactive)
       (set-input-method ,(cdr elt)))))
#+end_src

** Display settings

Group buffers by their major modes when using the contextual menu to
select a buffer.

#+begin_src emacs-lisp :tangle .emacs
(eval-after-load "mouse"
  (progn        
    (setq mouse-buffer-menu-mode-mult 2)
    (add-to-list 'mouse-buffer-menu-mode-groups '("Dired" . "Dired"))
    (add-to-list 'mouse-buffer-menu-mode-groups '("tex" . "TeX/LaTeX"))
    t))    
#+end_src

Highlight the current line in table based buffers and alike ones.

#+begin_src emacs-lisp :tangle .emacs
(dolist (hook '(tabulated-list-mode-hook
                bookmark-bmenu-mode-hook))
  (add-hook hook
            (lambda ()
              (hl-line-mode))))
#+end_src

** Frame customization definitions

#+begin_src emacs-lisp
(setq default-frame-alist
      '((height . 40)
	(width . 80)
	(menu-bar-lines . nil)
	(tool-bar-lines . nil)
	(vertical-scroll-bars . nil)
        (horizontal-scroll-bars . nil)
	(background-color . "#2e3434")
	(background-mode . dark)
	(foreground-color . "#eeeeec")
	(mouse-color . "#8ae234")
	(font . "Consolas-12")
	(cursor-color . "#fce94f")))
#+end_src

For X Window frames, it is better to customize the [[file:~/.Xresources][resources file]]:

#+begin_src x-resource-generic-mode
!Emacs colors
Emacs.foreground: #eeeeec
Emacs.background: #2e3434
Emacs.cursorColor: #fce94f
Emacs.borderColor: #2e3434
Emacs.pointerColor: #8ae234
Emacs.mouseColor: #8ae234

! Emacs frame customization
!Emacs.fullscreen: maximized
Emacs.menuBar: off
Emacs.toolBar: off
Emacs.verticalScrollBars: off
!Emacs.font: Inconsolata-13

! Emacs faces customization
Emacs.fringe.attributeBackground: grey20
Emacs.header-line.attributeBackground: grey30
Emacs.link.attributeForeground: cyan
Emacs.link.attributeUnderline: false
#+end_src

*** TODO Add the equivalent for MS Windows

** Documentation reader

#+begin_src emacs-lisp :tangle .emacs
(require 'info)
(define-key ctl-x-4-map "i" 'info-other-window)

(add-hook 'Info-mode-hook
	  (lambda ()
	     (setq truncate-lines t)))
#+end_src

I used to open frames to keep documentation away from the code; Thus
the interactive function =info-other-frame= is defined and bind to a
key.

#+begin_src emacs-lisp :tangle .emacs
(define-key ctl-x-5-map "i" 'info-other-frame)

(defun info-other-frame ()
  "Like `info' but put Info buffer in another frame.
Only intended for interactive use."
  (interactive)
  (let* ((win (selected-window))
	 (wdp (window-dedicated-p win))
	 value)
    (unwind-protect
	(progn
	  (set-window-dedicated-p win nil)
	  (switch-to-buffer-other-frame
	   (save-window-excursion
	     (setq value (call-interactively 'info))
	     (current-buffer))))
      (set-window-dedicated-p win wdp))
    value))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(let ((path (expand-file-name "~/.local/share/info/")))
  (when (file-accessible-directory-p path)
    (add-to-list 'Info-additional-directory-list path)))
#+end_src

** Server, daemon

A server is started if and only if the running process is not a daemon
and there is not already a server started. In that way the Emacs
client will always find someone to talk to.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'server-switch-hook 'raise-frame)

(load-library "server")
(when (not (or (server-running-p) (daemonp)))
  (server-start))
#+end_src

To have =emacsclient= called by =sudoedit=, =git= and other programs
when they are tell to edit a file, [[file:~/.bashrc][Bash configuration file]] contains
the following snippet:

#+begin_src shell-script-mode 
builtin type -p emacsclient &>/dev/null
[ -n $@ ] && export EDITOR=emacsclient
#+end_src

I also define an [[file:~/.bash_aliases][Bash alias]] to launch Emacs in terminals:

#+begin_src shell-script-mode
function is_command { type "$1" &> /dev/null; }
is_command emacs      && alias     em='emacsclient -t'
#+end_src

*** TODO Windows equivalent

** Desktop

The desktop file is saved in the user home directory. Only ten buffers
are restored immediately in order not to slow down start up. Tramp,
ftp and log buffers are not restored.

#+begin_src emacs-lisp :tangle .emacs
(load-library "desktop")
(desktop-save-mode)
(setq desktop-dirname (expand-file-name "~")
      desktop-restore-eager 10
      desktop-lazy-verbose nil
      desktop-files-not-to-save
      "\\(^/[^/:]*:\\|(ftp)$\\|.*\.log\\)")
#+end_src

** MinGW

In case there MinGW is installed, the list of directories where to
search programs, the =PATH= environment variable and the list of
directories where to search documentation files are extended.

Similar tweaks are done for Ghostscript, GNU Aspell, Visual Studio.

#+begin_src emacs-lisp :tangle .emacs
  (when (eq system-type 'windows-nt)
    (setq find-ls-option '("-exec ls -ld {} +" . "-ld"))
    (let ((mingw-root "C:\\GNU\\MinGW"))
      (when (file-exists-p mingw-root)
        ;; MinGW
        (setenv "PATH" (concat mingw-root "\\bin" ";" (getenv "PATH")))
        (add-to-list 'exec-path (expand-file-name "bin" mingw-root))
        (add-to-list 'Info-directory-list
                     (expand-file-name "share/info" mingw-root))
        ;; MSYS
        (let ((msys-root (concat mingw-root "\\msys\\1.0")))
          (when (file-exists-p msys-root)
            (setenv "PATH" (concat msys-root "\\bin" ";" (getenv "PATH")))
            (add-to-list 'exec-path (expand-file-name "bin" msys-root))
            (setenv "PATH" (concat msys-root "\\local\\bin"  ";" (getenv "PATH")))
            (add-to-list 'exec-path (expand-file-name "local/bin" msys-root))
            (add-to-list 'Info-directory-list
                         (expand-file-name "share/info" msys-root))
            (require 'grep)
            (grep-apply-setting 'grep-command
                                (expand-file-name "bin/grep.exe" msys-root))
            (grep-apply-setting 'grep-find-command
                                (expand-file-name "bin/find.exe" msys-root))))))
    (let ((gs-root "C:\\Program Files (x86)\\gs\\gs9.14"))
      (when (file-exists-p gs-root)
        (setenv "PATH" (concat gs-root "\\bin" ";" (getenv "PATH")))
        (setenv "PATH" (concat gs-root "\\lib" ";" (getenv "PATH")))
        (add-to-list 'exec-path (expand-file-name "bin" gs-root))
        (add-to-list 'exec-path (expand-file-name "lib" gs-root))
        (require 'doc-view)
        (setq doc-view-ghostscript-program "gswin32c.exe")))
    (let ((aspell-root "C:\\GNU\\aspell"))
      (when (file-exists-p aspell-root)
        (setenv "PATH" (concat aspell-root "\\bin" ";" (getenv "PATH")))
        (add-to-list 'exec-path (expand-file-name "bin" aspell-root))))
    (let ((visual-studio-root "C:\\Program Files (x86)\\Microsoft Visual Studio 10.0")
	  (dotnet-framework-root "C:\\Windows\\Microsoft.NET\\Framework\v4.0.30319"))
      (when (file-exists-p visual-studio-root)
        (setenv "PATH" (concat visual-studio-root "\\Common7\\IDE" ";" (getenv "PATH")))
        (add-to-list 'exec-path (expand-file-name "Common7/IDE" visual-studio-root))
        (add-to-list 'auto-mode-alist
               `(,(expand-file-name "VC/include" visual-studio-root) . c++-mode)))
      (when (file-exists-p dotnet-framework-root)
        (setenv "PATH" (concat dotnet-framework-root ";" (getenv "PATH"))))))
#+end_src

** Various

Tired of typing =yes= and =no=? Prefer =y= and =n=!

#+begin_src emacs-lisp :tangle .emacs
(fset 'yes-or-no-p 'y-or-n-p)
#+end_src

These are some core features disabled for newbies.

#+begin_src emacs-lisp :tangle .emacs
(put 'narrow-to-region 'disabled nil)
(put 'narrow-to-page 'disabled nil)
(put 'scroll-left 'disabled nil)
#+end_src

* Programming

** Spell checking

When writing code source, I like to have comments, documentation and
string checked for right spelling. But before one must check whether
there is a  spell checker in path or not.

#+begin_src emacs-lisp :tangle .emacs
(require 'ispell)
(setq has-spell-checker
      (not (eq (executable-find ispell-program-name) nil)))
(when has-spell-checker
  (add-hook 'prog-mode-hook
            (lambda ()
               (setq ispell-local-dictionary "english"
                     flyspell-persistent-highlight nil))))
#+end_src

*** TODO Disable spell menu when no spell program is found 	   :noexport:

** File parser

Visited buffers will always be parsed for their semantic content and a
list of most recently used tags is maintained.

#+begin_src emacs-lisp :tangle .emacs
(add-to-list 'semantic-default-submodes 'global-semantic-mru-bookmark-mode)
(semantic-mode)
#+end_src

** Speedbar and Minimap

I found that the speedbar is a nice way to browse files, tags and
documentation using the mouse. It deserved a key binding. But as I was
not using it much, I binded that key to minimap when available;
Minimap offers a visual way to browse large buffers.

** Long lines and buffer boundaries

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'prog-mode-hook
          (lambda ()
             (setq truncate-lines t
                   indicate-buffer-boundaries '((top . left) (bottom . right)))))
#+end_src
   
** Buffer indexes

Another way to browse tags found in the current buffer is to use the
index menu. A key binding is addded to programming modes to present to
the user the buffer indexes.

#+begin_src emacs-lisp :tangle .emacs
(setq imenu-auto-rescan t
      imenu-max-items 35)
(add-hook 'prog-mode-hook
          (lambda ()
             (local-set-key "\C-ci" 'imenu)))
#+end_src

** Completion

The typical Emacs behavior when completing is preferred: `Typical Emacs
behavior is to complete as much as possible, then pause waiting for
further input. Then if TAB is hit again, show a list of possible
completions.'

#+begin_src emacs-lisp :tangle .emacs
(setq pcomplete-cycle-completions nil)
#+end_src

By the way when reading file or buffer names the case will be ignored.

#+begin_src emacs-lisp :tangle .emacs
(setq read-file-name-completion-ignore-case t
      read-buffer-completion-ignore-case t)
#+end_src

The [[http://cx4a.org/software/auto-complete/][Auto Complete Mode]] rocks: Thus it is enabled wherever it is
possible.

#+begin_src emacs-lisp :tangle .emacs
(when (locate-library "auto-complete")
  (require 'auto-complete)
  (global-auto-complete-mode))
#+end_src

** Abbreviations

The file =~/.emacs.d/abbrev_defs= (or whatever the value of
=abbrev-file-name= is) defines abbreviations and their expansions. It
is read and saved silently.

#+begin_src emacs-lisp :tangle .emacs
(let ((file abbrev-file-name))
  (when (file-readable-p file)
    (read-abbrev-file file t)))
(setq save-abbrevs 'silently)
#+end_src

While editing buffers in programming modes, insertion of an
abbreviation is automatically expanded and replaced by its expansion.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'prog-mode-hook
          (lambda ()
             (abbrev-mode)))
#+end_src

An other way to use abbreviations is to expand letters in the buffer
before point by looking for other words that start with those letters
in buffers. Expansion is performed dynamically. I am hooked to this.
To limit the number of dynamic expansions when editing files using
naming conventions mixing uppercase and lowercase letters, case is
significant while searching for expansions.

#+begin_src emacs-lisp :tangle .emacs
(setq dabbrev-case-fold-search nil)
#+end_src

** Whitespaces

A key binding to cleanup blank problems in all buffer or at region.

#+begin_src emacs-lisp :tangle .emacs
(eval-after-load 'prog-mode
  (define-key prog-mode-map "\C-cw" 'whitespace-cleanup))
#+end_src

** Version control

I sometimes have directories both under [[http://subversion.apache.org/][Subversion]] and [[http://gitscm.org/][Git]]. As my
preferred version control backend is Git, the list of version control
backends must be reordered.

#+begin_src emacs-lisp :tangle .emacs
(setq vc-handled-backends (cons 'Git (remove 'Git vc-handled-backends)))
#+end_src

Comparing revisions using Ediff is so pleasant that it deserves a key
binding, an alternative to the usefull =C-xvD= (binded to
=vc-root-diff=).

#+begin_src emacs-lisp :tangle .emacs
(global-set-key "\C-xv=" 'ediff-revision)
#+end_src

Spell checking is automatically enabled when editing log messages,
whether working with Git or Subversion from a shell, or using Emacs
version control interface.

Note that, when working with Git from a shell, the buffer opened to
edit a log message has =default-generic-mode= enabled because its
content match =generic-find-file-regexp= and
=generic-use-find-file-hook= default value is =t= .

#+begin_src emacs-lisp :tangle .emacs
(when has-spell-checker
  (add-hook 'find-file-hook
            (lambda ()
               (when (string-match "^svn-commit" (buffer-name))
                 (setq ispell-local-dictionary "english")
                 (flyspell-mode))))

  (add-hook 'default-generic-mode-hook
            (lambda ()
               (when (equal (buffer-name) "COMMIT_EDITMSG")
                 (setq ispell-local-dictionary "english")
                 (flyspell-mode))))

  (add-hook 'log-edit-mode-hook
            (lambda ()
               (setq ispell-local-dictionary "english")
               (flyspell-mode))))
#+end_src

When using Git in an shell buffer I prefer not to have a pager
filtering the output.

#+begin_src emacs-lisp :tangle .emacs
(setenv "GIT_PAGER" "")
#+end_src

While merging changes, when the last conflic is resolved, don't leave
automaticaly =smerge-mode=; Otherwise I tend to use =smerge-mode= key
bindings after the mode has been deactivated.

#+begin_src emacs-lisp :tangle .emacs
(eval-after-load "smerge-mode"
  (setq smerge-auto-leave nil))
#+end_src

** Command interpreter

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'comint-mode-hook
	  (lambda ()
	     (if (fboundp 'ansi-color-for-comint-mode-on)
		 (autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t))
	     (setq comint-scroll-show-maximum-output t
		   indicate-empty-lines nil
		   comint-password-prompt-regexp 
		   "\\(\\([Ee]nter \\(?:same \\|the \\)?\\|[Oo]ld \\|[Nn]ew \\|'s \\|login \\|Kerberos \\|CVS \\|UNIX \\| SMB \\|LDAP \\|\\[sudo] \\|^\\)[Pp]assword\\( (again)\\)?\\|pass phrase\\|Mot de passe \\|\\(Enter \\|Repeat \\|Bad \\)?[Pp]assphrase\\)\\(?:, try again\\)?\\(?: for [^:]+\\)?:\\s *\\'")
	     (define-key comint-mode-map "\C-c\C-k" 'comint-kill-subjob)
	     (when (eq system-type 'windows-nt)
	       (setq comint-process-echoes 'on))))

(autoload 'ansi-color-for-comint-mode-on "ansi-color" nil t)
#+end_src

** Interactive shell

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'shell-mode-hook 
	  (lambda ()
	     (ansi-color-for-comint-mode-on)
	     (setq shell-prompt-pattern "^\[[^$#\n]*\][$#] *"
		   shell-font-lock-keywords
		   '(("[ \t]\\([+-][^ \t\n]+\\)" 1 font-lock-comment-face)
		     ("^\\[[1-9][0-9]*\\]" . font-lock-string-face))
		   comint-password-prompt-regexp
		   "\\(\\([Ee]nter \\(?:same \\|the \\)?\\|[Oo]ld \\|[Nn]ew \\|'s \\|login \\|Kerberos \\|CVS \\|UNIX \\| SMB \\|LDAP \\|\\[sudo] \\|^\\)[Pp]assword\\( (again)\\)?\\|pass phrase\\|Mot de passe \\|\\(Enter \\|Repeat \\|Bad \\)?[Pp]assphrase\\)\\(?:, try again\\)?\\(?: for [^:]+\\)?:\\s *\\'")))
#+end_src

An abbreviation is defined for =&> /dev/null=.

#+begin_src emacs-lisp :tangle .emacs
(define-abbrev-table 'shell-mode-abbrev-table '(("null" "&> /dev/null")))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'sh-mode-hook
	  (lambda ()
	     (define-key sh-mode-map "'" 'self-insert-command)))

(global-set-key [f9] 'shell)
#+end_src

** Terminal emulation

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'term-mode-hook
	  (lambda ()
	     (term-pager-toggle)))
#+end_src

** Compilation							   :noexport:

#+begin_src emacs-lisp
(add-hook 'compilation-mode-hook
	  (lambda ()
	     (setq truncate-partial-width-windows nil)))
#+end_src

I use the =f8= key to compile and recompile.

#+begin_src emacs-lisp :tangle .emacs
(global-set-key [f8] 'recompile)
(global-set-key [C-f8] 'compile)
#+end_src

*** TODO Send a D-BUS notification at the end of compilation	   :noexport:

Only if the compilation was lengthy.

** Make

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'makefile-gmake-mode-hook
	  (lambda ()
	     (setq tab-width 3)))
#+end_src

** Visual interface to diff and patch

Prefer to run the visual interface to diff in a single frame and split
that frame vertically or horizontally according to the frame geometry.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'ediff-mode-hook
          (lambda ()
             (setq ediff-window-setup-function 'ediff-setup-windows-plain)
             (when (< (* 2 (frame-height)) (frame-width))
               (setq ediff-split-window-function 'split-window-horizontally))))
#+end_src

White space visualization is useful when inspecting diffs.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'diff-mode-hook
          (lambda ()
             (whitespace-mode)))
#+end_src

** Debugger, GDB

#+begin_src emacs-lisp :tangle .emacs
(global-set-key [S-f8] 'gdb)

(add-hook 'gdb-mode-hook
	  (lambda ()
	     (setq gdb-show-changed-values t
		   gdb-use-colon-colon-notation nil
		   gdb-use-separate-io-buffer t)))

(add-hook 'gud-mode-hook
	  (lambda ()
	     (setq gud-tooltip-mode nil
		   gud-gdb-command-name "gdb --silent --annotate=3")))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defun alt-valgrind (file)
  (interactive "fEnter file: ")
  (shell-command (concat
		  "valgrind --leak-check=full  " file))
  (switch-to-buffer-other-window "*Shell Command Output*")
  (compilation-shell-minor-mode t))
#+end_src

** Support for C++

It is common for C++ developpers and C developpers to name their
header files with the =.h= extension. As I am more interested in C++,
the default is to visit such files in C++ mode. Whats more, candidate
extensions for the source file associated to a =.h= file are reordered
to privilege C++ usual extensions rather than C ones (see
=ff-find-other-file= binded to =C-co= for a way to switch between
implementation and declaration on a file name basis).

#+begin_src emacs-lisp :tangle .emacs
(add-to-list 'auto-mode-alist '("\\.h\\'" . c++-mode))

(require 'find-file)
(setcdr (assoc "\\.h\\'" cc-other-file-alist)
	(list (list ".cpp" ".cc" ".C" ".CC" ".cxx" ".c")))
#+end_src

Some abbreviation definitions for preprocessor directives are added.

#+begin_src emacs-lisp :tangle .emacs
(define-skeleton cc-preprocessor-conditional-group
  "Insert a C preprocessor conditional group"
  "Group macro: " "#ifdef " str ?\n _ ?\n"#endif // " str ?\n)

(define-skeleton cc-preprocessor-not-conditional-group
  "Insert a C preprocessor conditional group"
  "Group macro: " "#ifndef " str ?\n _ ?\n"#endif // " str ?\n)

(define-skeleton cc-preprocessor-create-macro
  "Insert a C preprocessor macro creation"
  "Macro name: " "#define " str " " (skeleton-read "Macro expansion: ") _)

(define-skeleton cc-preprocessor-include-directive
  "Insert a C preprocessor include directive"
  "Header name: " "#include " str _)

(define-abbrev-table 'c++-mode-abbrev-table
  '(("ppif" "" cc-preprocessor-conditional-group)
    ("ppnif" "" cc-preprocessor-not-conditional-group)
    ("ppd" "" cc-preprocessor-create-macro)
    ("ppi" "" cc-preprocessor-include-directive)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(require 'hideshow)
(add-hook 'c++-mode-hook
	  (lambda ()
	     (setq comment-style 'extra-line)
	     (setq indent-tabs-mode nil)
             (c-set-style "ellemtel")
	     (setq c-cleanup-list '(empty-defun-braces
				    one-liner-defun
				    defun-close-semi
				    scope-operator
				    list-close-comma)
		   c-basic-offset 3)
	     (c-toggle-electric-state)
	     (c-toggle-hungry-state)
	     (c-toggle-auto-newline)
	     (subword-mode)
	     (hs-minor-mode)
	     (cwarn-mode)
	     (require 'find-file)
	     (add-to-list ff-search-directories ".")
	     (define-key c++-mode-map "\C-co" 'ff-find-other-file)
	     (define-key c++-mode-map "\C-ck" 'tags-apropos)
	     (define-key c++-mode-map "\C-m" 'c-context-line-break)))
#+end_src

Update default text to insert into new files.

#+begin_src emacs-lisp :tangle .emacs
(add-to-list 'auto-insert-alist
             '(("\\.\\([Hh]\\|hh\\|hpp\\)\\'" . "C / C++ header")
  t "#pragma once\n\n"))
#+end_src

** Support for Emacs Lisp

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'emacs-lisp-mode-hook
	  (lambda ()
	     (set (make-local-variable 'comment-auto-fill-only-comments) t)
	     (set (make-local-variable 'imenu-sort-function) 
		  'imenu--sort-by-name)
	     (outline-minor-mode t)
	     (define-key emacs-lisp-mode-map "\C-c\C-f" 
	       'emacs-lisp-byte-compile)))
#+end_src

To speedup Emacs Lisp execution, code can be compiled. The following
will compile a buffer on save if and only if an associated
byte-compiled file already exists.

#+begin_src emacs-lisp :tangle .emacs
(defun byte-compile-current-buffer ()
  "Compile the current buffer if its major mode is
`emacs-lisp-mode' and an associated compiled file already
exists."
  (interactive) 
  (when
      (and (eq major-mode 'emacs-lisp-mode)
           (file-exists-p (byte-compile-dest-file buffer-file-name)))
    (byte-compile-file buffer-file-name)))

(add-hook 'after-save-hook 'byte-compile-current-buffer)
#+end_src

** Support for Python

Some Linux distributions (e.g. Arch Linux) ship with both Python 2.x
and 3.x, thus the list of interpreters must be expanded accordingly
for file mode determination.

#+begin_src emacs-lisp :tangle .emacs
(eval-after-load "python"
  (when (executable-find "python2")
    (setq python-shell-interpreter "python2")))
#+end_src

The style used for docstring is the one found in Django code source.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'python-mode-hook
          (lambda ()
             (setq tab-width 4
                   gud-pdb-command-name "python -m pdb "
                   python-fill-docstring-style 'pep-257
                   python-check-command "pep8")))
#+end_src

The Python documentation used to be distributed in Texinfo format. It
is not the case anymore since the documentation is handled by the
Sphinx framework. But it is still possible to generate Texinfo files
using Sphinx; Such files are easy to find on the web (if you don't
want to generate them by yourself...). The =info-look= setting for
=python-mode= must be updated to those new files.

#+begin_src emacs-lisp :tangle .emacs
(eval-after-load "info-look" 
  '(info-lookup-add-help
    :mode 'python-mode
    :regexp "[[:alnum:]_]+"
    :doc-spec '(("(python)Index" nil ""))))
#+end_src

When available, load the package =flymake-python-pyflakes= to check
code on the fly.

#+begin_src emacs-lisp :tangle .emacs
(when (locate-library "flymake-python-pyflakes")
  (require 'flymake-python-pyflakes)
  (add-hook 'python-mode-hook 'flymake-python-pyflakes-load))
#+end_src

Common skeletons and abbreviations are defined (PDB call, =import=
statement, etc).

#+begin_src emacs-lisp :tangle .emacs
(define-abbrev-table 'python-mode-abbrev-table
  '(("pdb" "import pdb; pdb.set_trace()")))
#+end_src

Set the name of the Python template to insert at file creation. 

#+begin_src emacs-lisp :tangle .emacs
(let ((filename "python_template.py"))
  (when (file-exists-p (expand-file-name filename auto-insert-directory))
    (add-to-list 'auto-insert-alist
                 `(python-mode . ,filename))))
#+end_src

** Support for Scheme

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'scheme-mode-hook
	  (lambda ()
	     (setq scheme-program-name "umb-scheme")))
#+end_src

** Support for JavaScript

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'js-mode-hook
          (lambda ()
             (setq indent-tabs-mode nil)
             (subword-mode)
             (hs-minor-mode)))
#+end_src

When available, load the package =flymake-jslint= to check code on the
fly.

#+begin_src emacs-lisp :tangle .emacs
(when (locate-library "flymake-jslint")
  (load-library "flymake-jslint")
  (add-hook 'js-mode-hook 'flymake-jslint-load))
#+end_src
   
** Support for SQL

Most of the databases I use are PostgreSQL databases. Buffers in SQL
mode will be properly highlighted thanks to the following setting.

#+begin_src emacs-lisp :tangle .emacs 
(require 'sql)
(setq sql-product 'postgres)
#+end_src

Hitting =;= in an interactive SQL buffer will send the current input
to the process.

#+begin_src emacs-lisp :tangle .emacs 
(setq sql-electric-stuff t)
#+end_src

** Support for PHP

#+begin_src emacs-lisp :tangle .emacs
(when (locate-library "php-mode")
  (load-library "php-mode")
  (add-hook 'php-mode-hook 'flymake-mode))
#+end_src

* Text edition

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'text-mode-hook
	  (lambda ()
	     (setq sentence-end 
		   "[.?!]\\($\\| $\\|	\\| \\)[ 	\n]*"
		   sentence-end-double-space nil)
 	     (auto-fill-mode)
	     (goto-address-mode)
	     (use-hard-newlines 1 'never)))
#+end_src

I found that on-the-fly reindentation is confusing in text modes, so
it is disabled.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'text-mode-hook
          (lambda ()
             (set (make-local-variable 'electric-indent-functions)
                  (list (lambda (arg) 'no-indent)))))
#+end_src

Sometime I refer to my bibliography database outside of a TeX/LaTeX
buffer.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'text-mode-hook
          (lambda ()
             (local-set-key "\C-c["
                            (lambda ()
                               (interactive)
                               (require 'reftex)
                               (let ((reftex-cite-format 'locally)) 
                                 (reftex-citation))))))
#+end_src

** Support for SGML, HTML, CSS

It is difficult to avoid long lines when writing SGML files, thus
automatic line breaking is turned off.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'html-mode-hook
          (lambda ()
             (auto-fill-mode -1)
             (abbrev-mode)
             (when has-spell-checker
               (flyspell-mode))))
#+end_src

An abbreviation is defined for the Lorem Ipsum.

#+begin_src emacs-lisp :tangle .emacs
(define-abbrev-table 'html-mode-abbrev-table
  '(("lorem" 
     "<p>Lorem ipsum dolor sit amet, consectetur adipisicing
elit, sed do eiusmod tempor incididunt ut labore et dolore magna
aliqua. Ut enim ad minim veniam, quis nostrud exercitation
ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis
aute irure dolor in reprehenderit in voluptate velit esse cillum
dolore eu fugiat nulla pariatur. Excepteur sint occaecat
cupidatat non proident, sunt in culpa qui officia deserunt mollit
anim id est laborum.</p>")))
#+end_src

When available, load the package =flymake-csslint= to check code on the
fly.

#+begin_src emacs-lisp :tangle .emacs
(when (locate-library "flymake-csslint")
  (require 'flymake-csslint)
  (add-hook 'css-mode-hook 'flymake-mode))
#+end_src

When available, load the package =irfc= providing an interface to IETF
RFC documents.

#+begin_src emacs-lisp :tangle .emacs
(when (locate-library "irfc")
  (require 'irfc)
  (setq irfc-assoc-mode t))
#+end_src

** Support for TeX and LaTeX

When a file with =.tex= extension is opened, it is parsed to identify
if it is a TeX or a LaTeX file. The latter will be the default if the
parsing fails to identify whether it is a TeX or a LaTeX file. Next,
the list of regions to be skipped while spell checking a buffer in TeX
mode is extended (most of the time =\ref= and =\label= parameters are
acronyms not recognized by the spell checker).

#+begin_src emacs-lisp :tangle .emacs
(setq tex-default-mode 'latex-mode)
(setq ispell-tex-skip-alists
      (cons
       (let ((list (car ispell-tex-skip-alists)))
	 (add-to-list 'list '("\\\\\\(ref\\|label\\)" ispell-tex-arg-end)))
       (cdr ispell-tex-skip-alists)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(setq latex-run-command "latex -src-specials -interaction=nonstopmode")
(add-hook 'latex-mode-hook
	  (lambda ()
	     (setq comment-style 'plain
		   comment-column 0
		   indent-tabs-mode nil
		   ispell-check-comments nil
		   tex-trailer "\\end{document}"
		   latex-block-default "theorem"
		   latex-block-names
		   '("theorem" "proposition" "definition" "lemma" "multline")
		   tex-open-quote "\\og "
		   tex-close-quote "\\fg"
		   tex-alt-dvi-view-command
		   `(let ((line (count-lines 1 (point)))
			  (source (file-name-nondirectory (buffer-file-name))))
		      (concat "xdvi -sourceposition " 
			      (number-to-string line) source " *")))
	     (define-skeleton alt-latex-math-env
	       "Create a matching pair of parenthesis."
	       nil 92 40 _ 92 41)
	     (define-skeleton alt-latex-displaymath-env
	       "Create a matching pair of brackets."
	       nil 92 91 _ 92 93)
	     (add-to-list 'tex-compile-commands
			  '("xdg-open %r.pdf &" "%r.pdf"))
	     (reftex-mode t)
	     (outline-minor-mode 1)
	     (define-key latex-mode-map [M-tab] 'info-complete-symbol)
	     (define-key latex-mode-map "\C-c\C-s" 'alt-latex-section)
	     (define-key latex-mode-map "\C-cm" 'alt-latex-math-env)
	     (define-key latex-mode-map "\C-cM" 'alt-latex-displaymath-env)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'tex-shell-hook
	  (lambda ()
	     (add-to-list 'shell-font-lock-keywords
		    '("^\\(LaTeX Warning:\\|\\!\\)" . font-lock-warning-face))
	     (define-key tex-shell-map "\C-c\C-p" 'comint-previous-prompt)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defun alt-auto-insert-latex ()
  "Ask the user for a LaTeX class and a language name, then
insert the corresponding template file in current buffer.

The relative name of the template file is LaTeX/CLASS-LANG.tex or
LaTeX/CLASS.tex if language is empty. This file is taken in the
directory `auto-insert-directory'.

If class is empty, the current buffer is expected to belong to a
multi-file document; The user is asked for the name of the main
document, then a skeleton with a reference to that name is
inserted."
  (let* ((class (completing-read "Document class: "
				 '(("article" 1) ("report" 2) ("book" 3)
				   ("letter" 4) ("slides" 5) ("exam" 6))))
	 (lang (when (not (equal class ""))
		 (completing-read "Main language: "
				  '(("french" 1) ("english" 2))))))
    (if (not (equal class ""))
	(let ((name (expand-file-name 
		     (concat auto-insert-directory "LaTeX/" class
			     (when (not (equal lang "")) 
			       (concat "-" lang)) ".tex"))))
	  (if (file-readable-p name)
	      (progn
		(insert "% Time-stamp: <" (current-time-string)
			" " (user-login-name) ">\n% Author: "
			(user-full-name) " <" (progn user-mail-address) ">\n\n")
		(insert-file-contents name))
	    (message "No template file %s found" name)))
      (let ((name (read-file-name "Main file: " default-directory "")))
	(insert "% Time-stamp: <" (current-time-string)
		" " (user-login-name) ">\n% Author: " (user-full-name)
		" <" (progn user-mail-address) ">\n\n")
	(goto-char (point))
	(when (not (equal name ""))
	  (save-excursion
	    (insert "\n\n% Local Variables:\n% tex-main-file: \""
		    name "\"\n% End:\n")))))))

(add-to-list 'auto-insert-alist
	     '(latex-mode . alt-auto-insert-latex))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'reftex-mode-hook
	  (lambda ()
	     (setq reftex-extra-bindings t
		   reftex-enable-partial-scans t
		   reftex-save-parse-info nil
		   reftex-use-multiple-selection-buffers t
		   reftex-label-alist
		   (setq reftex-label-alist
			 '(("theorem" ?h "thr:" "~\\ref{%s}" t 
			    (regexp "th\\\(\\\(é\\\|\'e\\\)or\\\(è\\\|\`e\\\)mes?\\\|m\\\.\\\)") nil)
			   ("proposition" ?p "pro:" "~\\ref{%s}" t 
			    (regexp "prop\\\(ositions?\\\|.\\\)") nil)
			   ("lemma" ?l "lem:" "~\\ref{%s}" t 
			    (regexp "lem\\\(mes?\\\|.\\\)") nil)
			   ("equation" 101 "eq:" "~(\\ref{%s})" t
			    (regexp "\\\(l'\\\)?\\\(é\\\|\'e\\\)quations?") nil)
			   ("example" ?x "exm:" "~\\ref{%s}" t 
			    (regexp "exemp\\\(les?\\\|.\\\)")))))
	     (defun reftex-page-reference ()
	       "Make a LaTeX reference to a page number."
	       (interactive)
	       (let ((reftex-format-ref-function
		      `(lambda (label format)
			 (concat "~\\pageref{" label "}"))))
		 (reftex-reference)))
	     (define-key reftex-mode-map "\C-c]" 'reftex-page-reference)
	     (define-key-after reftex-mode-menu [pageref]
	       '(menu-item "\\pageref" reftex-page-reference) '\\cite)))

(eval-after-load "reftex"
  '(let ((dir (expand-file-name "~/Documents/Mathématiques/Bibliographie")))
     (when (file-exists-p dir)
       (dolist (name (directory-files dir t ".*\.bib$"))
	 (add-to-list 'reftex-default-bibliography name)))))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defcustom latex-outline-max-level 4
  "Maximum level of outline headings used by imenu."
  :type 'integer
  :group 'tex)
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defadvice latex-imenu-create-index (before cut-section-alist activate)
  "Cut `latex-section-alist' to have max `latex-outline-max-level' in
`imenu' menu."
  (setq temp-latex-section-alist latex-section-alist)
  (set (make-local-variable 'latex-section-alist)
       (let (list)
	 (dolist (elt (default-value 'latex-section-alist))
	   (if (<= (cdr elt) latex-outline-max-level)
	       (push elt list)))
	 list)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defadvice latex-imenu-create-index (before cut-metasection-list activate)
  "Cut `latex-metasection-alist' to get rid of \\end{document} entries
in `imenu' menu."
  (setq temp-latex-metasection-list latex-metasection-list)
  (set (make-local-variable 'latex-metasection-list)
       (remove "end{document}" latex-metasection-list)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defadvice latex-imenu-create-index 
  (after restore-latex-metasection-list activate)
  "Restore `latex-metasection-list' default value."
  (setq latex-metasection-list temp-latex-metasection-list))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defadvice latex-imenu-create-index 
  (after restore-latex-section-alist activate)
  "Restore `latex-section-alist' default value."
  (setq latex-section-alist temp-latex-section-alist))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(defvar tex-alt-dvi-view-command nil)

(defun alt-tex-view (&optional alt)
  "Like \\[tex-view] but allows use of alternative command.

If prefix argument is provided, use the alternative command,
`tex-alt-dvi-view-command'."
  (interactive "P")
  (or tex-dvi-view-command
      (error "You must set `tex-dvi-view-command'"))
  (let ((tex-dvi-print-command
	 (if alt tex-alt-dvi-view-command
	   tex-dvi-view-command)))
    (tex-print)))

(defvar alt-latex-section-default "paragraph")

(define-skeleton alt-latex-section
  "Create a sectionning command \\SECTION{TITLE} at point."
  (let ((section (completing-read 
		  (format "LaTeX section name [%s]: " 
			  alt-latex-section-default)
		  latex-section-alist nil nil nil nil 
		  alt-latex-section-default)))
    (setq alt-latex-section-default section))
  \n "\\" str ?\{ (skeleton-read "Title: ") ?\} \n \n)
#+end_src

** Support for dict protocol

#+begin_src emacs-lisp :tangle .emacs
(when (locate-library "dictionary")
  (load-library "dictionary")
  (define-key dictionary-mode-map [backtab] 'dictionary-prev-link))
#+end_src

** Support for reStructuredText

Auto fill mode may break the indentation.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'rst-mode-hook
          (lambda ()
            (auto-fill-mode -1)))
#+end_src
** Org mode

#+begin_src emacs-lisp :tangle .emacs
(setq org-hide-leading-stars t
      org-log-done 'time
      org-directory (expand-file-name "~/.emacs.d/org")
      org-default-notes-file (expand-file-name "notes.org" org-directory))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(when (featurep 'windmove)
  (add-hook 'org-shiftup-final-hook 'windmove-up)
  (add-hook 'org-shiftleft-final-hook 'windmove-left)
  (add-hook 'org-shiftdown-final-hook 'windmove-down)
  (add-hook 'org-shiftright-final-hook 'windmove-right))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(define-key global-map "\C-cr" 'org-capture)
(define-key global-map "\C-ca" 'org-agenda)
#+end_src

Org files have an option to set the language to use for translations
while exporting to HTML. When this option is set, one can deduce the
dictionary to use for spell checking. By the way I like to spell check
Org buffers on the fly.

#+begin_src emacs-lisp :tangle .emacs
(when has-spell-checker
  (add-hook 'org-mode-hook
   (lambda ()
      (require 'ispell)
      (ispell-set-spellchecker-params)
      (require 'ox)
      (let ((lang (plist-get (org-export-get-environment) :language)))
        (when (and lang (assoc lang ispell-dictionary-alist))
          (setq ispell-local-dictionary lang)))
      (flyspell-mode 1))))
#+end_src

Various types of capture items are defined.

#+begin_src emacs-lisp :tangle .emacs
(require 'org-capture)
(add-to-list 'org-capture-templates
      '("t" "Todo" entry (file+headline "notes.org" "Tasks")
        "* TODO %?\n  %i\n  %a"))
(add-to-list 'org-capture-templates
             `("f" "Film" entry (file+headline "films.org" ,(format-time-string "%Y"))
               "** %?\n   :PROPERTIES:\n   :Date: %u\n   :END:\n%i "))
#+end_src

* File management

** Replace deletion by move to trash

#+begin_src emacs-lisp :tangle .emacs
(setq delete-by-moving-to-trash t)
#+end_src

** Jumping and viewing

#+begin_src emacs-lisp :tangle .emacs
(autoload 'dired-jump "dired" "\
     Jump to Dired buffer corresponding to current buffer.
     If in a file, Dired the current directory and move to file's line.
     If in Dired already, pop up a level and goto old directory's line.
     In case the proper Dired file line cannot be found, refresh the Dired
     buffer and try again." t nil)

(autoload 'dired-jump-other-window "dired" "\
     Like \\[dired-jump] (dired-jump) but in other window." t nil) 

(define-key ctl-x-map "\C-j" 'dired-jump)

(define-key ctl-x-4-map "\C-j" 'dired-jump-other-window)
(define-key ctl-x-4-map "v" 'view-file-other-window)

(define-key ctl-x-5-map "v" 'view-file-other-frame)
(define-key ctl-x-5-map "c" 'alt-clone-indirect-buffer-other-frame)
#+end_src

** Enhancing file manager

#+begin_src emacs-lisp :tangle .emacs
(require 'dired-x)
(add-hook 'dired-load-hook
	  (lambda ()
             (load-library "dired-x")
	     (setq dired-x-hands-off-my-keys nil)
             (dired-bind-find-file)
	     (setq dired-free-space-args "-Pk"
		   dired-listing-switches "-al")
	     (setq dired-isearch-filenames t)))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(when (locate-library "gnus-dired")
  (require 'gnus-dired))
(setq dired-omit-files
      (concat dired-omit-files
	      "\\|^\\..+\\|^CVS$\\|^lost\\+found")
      dired-omit-extensions (delete ".pdf" dired-omit-extensions))
(add-hook 'dired-mode-hook
	  (lambda ()
	     (when (fboundp 'gnus-dired-mode)
	       (gnus-dired-mode 1))
	     (setq dired-omit-files-p t
		   dired-omit-size-limit nil
		   truncate-lines t)
	     (set (make-local-variable 'transient-mark-mode) nil)
	     (define-key dired-mode-map "w" 'dired-copy-filename-as-kill)))
#+end_src

* Mail, newsgroup, RSS

** Usenet, RSS and electronic mail

I use Gnus for Usenet forums, RSS feeds and electronic mail. All
configuration files goes into =~/.emacs.d=.

#+begin_src emacs-lisp :tangle .emacs
(setq read-mail-command 'gnus
      mail-user-agent 'gnus-user-agent
      message-directory (expand-file-name "~/.emacs.d/Mail")
      gnus-home-directory (expand-file-name "~/.emacs.d/"))
#+end_src

Quit reading news before killing emacs.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'kill-emacs-hook
	  (lambda ()
	     (when (and (fboundp 'gnus-alive-p) (gnus-alive-p))
	       (gnus-group-exit))))
#+end_src

Group topics are enabled by default.

#+begin_src emacs-lisp :tangle .emacs
(add-hook 'gnus-group-mode-hook 'gnus-topic-mode)
#+end_src

Maill servers are scanned every 2 minutes.

#+begin_src emacs-lisp :tangle .emacs
(require 'gnus-demon)
(gnus-demon-add-scanmail)
#+end_src

#+begin_src emacs-lisp :tangle .gnus.el
(setq gnus-nntp-server nil
      gnus-select-method
      '(nnimap "gmail" 
	       (nnimap-address "imap.gmail.com")
	       (nnimap-server-port 993)
	       (nnimap-stream ssl))
      gnus-secondary-select-methods
      '((nntp "free"
	     (nntp-address "news.free.fr"))))

(setq message-send-mail-function 'smtpmail-send-it
      smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
      smtpmail-auth-credentials '(("smtp.gmail.com" 587 "orontee@gmail.com" nil))
      smtpmail-default-smtp-server "smtp.gmail.com"
      smtpmail-smtp-server "smtp.gmail.com"
      smtpmail-smtp-service 587
      smtpmail-local-domain "localdomain")
#+end_src

To view images using Eye Of Gnome I have created the file:~/.mailcap
with the following content.

#+begin_src 
image/jpeg; eog %s
#+end_src

Atom feeds must be converted before Gnus can parsed them. The
file:~/.emacs.d/atom2rss.xsl can be downloaded from
http://atom.geekhood.net/.

#+begin_src 
(require 'mm-url)
(defadvice mm-url-insert (after DE-convert-atom-to-rss () )
  "Converts atom to RSS by calling xsltproc."
  (when (re-search-forward "xmlns=\"http://www.w3.org/.*/Atom\""
			   nil t)
    (goto-char (point-min))
    (message "Converting Atom to RSS... ")
    (call-process-region (point-min) (point-max)
			 "xsltproc"
			 t t nil
			 (expand-file-name "~/.emacs.d/atom2rss.xsl") "-")
    (goto-char (point-min))
    (message "Converting Atom to RSS... done")))

(ad-activate 'mm-url-insert)
#+end_src

** Message writing

#+begin_src emacs-lisp :tangle .emacs
(setq user-mail-address "orontee@gmail.com"
      user-full-name "Matthias Meulien")
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(require 'message)
(add-hook 'message-mode-hook
	  (lambda ()
	     (setq message-elide-ellipsis "\n> (...)\n"
		   message-signature t) 
	     (setq message-completion-alist
		   '(("^\\(Newsgroups\\|Followup-To\\|Posted-To\\|Gcc\\):" . message-expand-group)
		     ("^\\(Resent-\\)?\\(To\\|B?Cc\\):" . eudc-expand-inline)
		     ("^\\(Reply-To\\|From\\|Mail-Followup-To\\|Mail-Copies-To\\):" . eudc-expand-inline)
		     ("^\\(Disposition-Notification-To\\|Return-Receipt-To\\):" . message-expand-name)))
	     (setq ispell-message-dictionary-alist
		   '(("^To:[^\n,]+\\.fr[ \t\n,>]" . "francais")
		     ("^Newsgroups:[ \t]*fr\\." . "francais")
		     ("^Newsgroups:[ \t]*[^f]" . "english")))))
#+end_src

#+begin_src emacs-lisp :tangle .emacs
(setq gnus-posting-styles
      '((".*"
         (signature "Matthias"))
        ("^CELAD"
         (address "matthias.meulien@celad.com")
         (signature "Matthias Meulien\nIngénieur d'Étude - CELAD")
         (organization "CELAD"))))
#+end_src

* Code sources 							   :noexport:

#+name: .emacs_header
#+begin_src emacs-lisp
;;; -*- coding: utf-8; -*-
;;; GNU Emacs Startup file

;;; WARNING This file was automatically generated: Do not edit
#+end_src

#+name: .emacs_custom-file_loading
#+begin_src emacs-lisp :tangle .emacs
(require 'cus-edit)
(setq custom-file (expand-file-name 
                   (concat  "~/.emacs.d/" system-name "-custom.el")))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src
   
#+name: .emacs_system-name_loading
#+begin_src emacs-lisp :tangle .emacs
(let ((file (locate-library (concat (system-name) ".el"))))
  (if file
      (load file t)
    (message "No machine specific initialization")))
#+end_src



# Local Variables:
# Mode: org
# End:
